{"version":3,"file":"common-2c6a7547.cjs.js","sources":["../src/auth/user.ts","../src/core/version.ts","../src/util/log.ts","../src/platform/browser/format_json.ts","../src/util/assert.ts","../src/util/error.ts","../src/util/promise.ts","../src/api/credentials.ts","../src/platform/browser/random_bytes.ts","../src/util/misc.ts","../src/model/path.ts","../src/model/document_key.ts","../src/util/input_validation.ts","../src/util/json_validation.ts","../src/lite-api/timestamp.ts","../src/core/snapshot_version.ts","../src/model/field_index.ts","../src/local/persistence_transaction.ts","../src/local/local_store.ts","../src/local/persistence_promise.ts","../src/local/simple_db.ts","../src/local/index_backfiller.ts","../src/core/listen_sequence.ts","../src/util/types.ts","../src/local/encoded_resource_path.ts","../src/local/indexeddb_schema_legacy.ts","../src/local/indexeddb_sentinels.ts","../src/local/indexeddb_transaction.ts","../src/util/obj.ts","../src/util/sorted_map.ts","../src/util/sorted_set.ts","../src/model/field_mask.ts","../src/util/base64_decode_error.ts","../src/platform/browser/base64.ts","../src/util/byte_string.ts","../src/model/normalize.ts","../src/model/server_timestamps.ts","../src/core/database_info.ts","../src/model/values.ts","../src/model/object_value.ts","../src/model/document.ts","../src/core/bound.ts","../src/core/order_by.ts","../src/core/filter.ts","../src/core/target.ts","../src/core/query.ts","../src/util/obj_map.ts","../src/model/collections.ts","../src/remote/number_serializer.ts","../src/model/transform_operation.ts","../src/model/mutation.ts","../src/model/mutation_batch.ts","../src/model/overlay.ts","../src/core/aggregate.ts","../src/remote/existence_filter.ts","../src/remote/rpc_error.ts","../src/util/testing_hooks_spi.ts","../src/platform/browser/text_serializer.ts","../src/remote/bloom_filter.ts","../src/remote/remote_event.ts","../src/remote/watch_change.ts","../src/remote/serializer.ts","../src/local/target_data.ts","../src/local/local_serializer.ts","../src/local/indexeddb_bundle_cache.ts","../src/local/indexeddb_document_overlay_cache.ts","../src/local/indexeddb_globals_cache.ts","../src/index/firestore_index_value_writer.ts","../src/index/ordered_code_writer.ts","../src/index/index_byte_encoder.ts","../src/index/index_entry.ts","../src/model/target_index_matcher.ts","../src/util/logic_utils.ts","../src/local/memory_index_manager.ts","../src/local/indexeddb_index_manager.ts","../src/local/lru_garbage_collector.ts","../src/local/indexeddb_mutation_batch_impl.ts","../src/local/indexeddb_mutation_queue.ts","../src/core/target_id_generator.ts","../src/local/indexeddb_target_cache.ts","../src/local/lru_garbage_collector_impl.ts","../src/local/indexeddb_lru_delegate_impl.ts","../src/local/remote_document_change_buffer.ts","../src/local/indexeddb_remote_document_cache.ts","../src/local/overlayed_document.ts","../src/local/local_documents_view.ts","../src/local/memory_bundle_cache.ts","../src/local/memory_document_overlay_cache.ts","../src/local/memory_globals_cache.ts","../src/local/reference_set.ts","../src/local/memory_mutation_queue.ts","../src/local/memory_remote_document_cache.ts","../src/local/memory_target_cache.ts","../src/local/memory_persistence.ts","../src/local/indexeddb_schema_converter.ts","../src/local/indexeddb_persistence.ts","../src/local/indexeddb_schema.ts","../src/local/local_view_changes.ts","../src/local/query_context.ts","../src/local/query_engine.ts","../src/local/local_store_impl.ts","../src/local/shared_client_state_schema.ts","../src/local/shared_client_state.ts","../src/remote/connectivity_monitor_noop.ts","../src/platform/browser/connectivity_monitor.ts","../src/util/debug_uid.ts","../src/remote/rest_connection.ts","../src/remote/stream_bridge.ts","../src/platform/browser/webchannel_connection.ts","../src/platform/browser/connection.ts","../src/platform/browser/dom.ts","../src/platform/browser/serializer.ts","../src/remote/backoff.ts","../src/remote/persistent_stream.ts","../src/remote/datastore.ts","../src/remote/online_state_tracker.ts","../src/remote/remote_store.ts","../src/util/async_queue.ts","../src/model/document_set.ts","../src/core/view_snapshot.ts","../src/core/event_manager.ts","../src/util/bundle_reader.ts","../src/core/bundle_impl.ts","../src/core/view.ts","../src/core/sync_engine_impl.ts","../src/core/component_provider.ts","../src/util/byte_stream.ts","../src/util/async_observer.ts","../src/util/bundle_reader_impl.ts","../src/util/bundle_reader_sync_impl.ts","../src/core/transaction.ts","../src/core/transaction_runner.ts","../src/core/firestore_client.ts","../src/platform/browser/byte_stream_reader.ts","../src/util/array.ts","../src/api/long_polling_options.ts","../src/lite-api/components.ts","../src/lite-api/settings.ts","../src/lite-api/database.ts","../src/lite-api/reference.ts","../src/util/async_queue_impl.ts","../src/api/bundle.ts","../src/api/database.ts","../src/lite-api/bytes.ts","../src/lite-api/field_path.ts","../src/lite-api/field_value.ts","../src/lite-api/geo_point.ts","../src/lite-api/vector_value.ts","../src/lite-api/user_data_reader.ts","../src/lite-api/user_data_writer.ts","../src/api/user_data_writer.ts","../src/lite-api/field_value_impl.ts","../src/core/options_util.ts","../src/core/structured_pipeline.ts","../src/remote/internal_serializer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nexport class User {\n  /** A user with a null UID. */\n  static readonly UNAUTHENTICATED = new User(null);\n\n  // TODO(mikelehen): Look into getting a proper uid-equivalent for\n  // non-FirebaseAuth providers.\n  static readonly GOOGLE_CREDENTIALS = new User('google-credentials-uid');\n  static readonly FIRST_PARTY = new User('first-party-uid');\n  static readonly MOCK_USER = new User('mock-user');\n\n  constructor(readonly uid: string | null) {}\n\n  isAuthenticated(): boolean {\n    return this.uid != null;\n  }\n\n  /**\n   * Returns a key representing this user, suitable for inclusion in a\n   * dictionary.\n   */\n  toKey(): string {\n    if (this.isAuthenticated()) {\n      return 'uid:' + this.uid;\n    } else {\n      return 'anonymous-user';\n    }\n  }\n\n  isEqual(otherUser: User): boolean {\n    return otherUser.uid === this.uid;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** The semver (www.semver.org) version of the SDK. */\nimport { version } from '../../../firebase/package.json';\nexport let SDK_VERSION = version;\nexport function setSDKVersion(version: string): void {\n  SDK_VERSION = version;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger, LogLevel, LogLevelString } from '@firebase/logger';\n\nimport { SDK_VERSION } from '../core/version';\nimport { formatJSON } from '../platform/format_json';\n\nexport { LogLevel, LogLevelString };\n\nconst logClient = new Logger('@firebase/firestore');\n\n// Helper methods are needed because variables can't be exported as read/write\nexport function getLogLevel(): LogLevel {\n  return logClient.logLevel;\n}\n\n/**\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\n *\n * @param logLevel - The verbosity you set for activity and error logging. Can\n *   be any of the following values:\n *\n *   <ul>\n *     <li>`debug` for the most verbose logging level, primarily for\n *     debugging.</li>\n *     <li>`error` to log errors only.</li>\n *     <li><code>`silent` to turn off logging.</li>\n *   </ul>\n */\nexport function setLogLevel(logLevel: LogLevelString): void {\n  logClient.setLogLevel(logLevel);\n}\n\nexport function logDebug(msg: string, ...obj: unknown[]): void {\n  if (logClient.logLevel <= LogLevel.DEBUG) {\n    const args = obj.map(argToString);\n    logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n  }\n}\n\nexport function logError(msg: string, ...obj: unknown[]): void {\n  if (logClient.logLevel <= LogLevel.ERROR) {\n    const args = obj.map(argToString);\n    logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n  }\n}\n\n/**\n * @internal\n */\nexport function logWarn(msg: string, ...obj: unknown[]): void {\n  if (logClient.logLevel <= LogLevel.WARN) {\n    const args = obj.map(argToString);\n    logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n  }\n}\n\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj: unknown): string | unknown {\n  if (typeof obj === 'string') {\n    return obj;\n  } else {\n    try {\n      return formatJSON(obj);\n    } catch (e) {\n      // Converting to JSON failed, just log the object directly\n      return obj;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Formats an object as a JSON string, suitable for logging. */\nexport function formatJSON(value: unknown): string {\n  return JSON.stringify(value);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SDK_VERSION } from '../core/version';\n\nimport { logError } from './log';\n\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n *\n * @param code - generate a new unique value with `yarn assertion-id:generate`\n * Search for an existing value using `yarn assertion-id:find X`\n */\nexport function fail(\n  code: number,\n  message: string,\n  context?: Record<string, unknown>\n): never;\n\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n *\n * @param id - generate a new unique value with `yarn assertion-id:generate`\n * Search for an existing value using `yarn assertion-id:find X`\n */\nexport function fail(id: number, context?: Record<string, unknown>): never;\n\nexport function fail(\n  id: number,\n  messageOrContext?: string | Record<string, unknown>,\n  context?: Record<string, unknown>\n): never {\n  let message = 'Unexpected state';\n  if (typeof messageOrContext === 'string') {\n    message = messageOrContext;\n  } else {\n    context = messageOrContext;\n  }\n  _fail(id, message, context);\n}\n\nfunction _fail(\n  id: number,\n  failure: string,\n  context?: Record<string, unknown>\n): never {\n  // Log the failure in addition to throw an exception, just in case the\n  // exception is swallowed.\n  let message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ${failure} (ID: ${id.toString(\n    16\n  )})`;\n  if (context !== undefined) {\n    try {\n      const stringContext = JSON.stringify(context);\n      message += ' CONTEXT: ' + stringContext;\n    } catch (e) {\n      message += ' CONTEXT: ' + context;\n    }\n  }\n  logError(message);\n\n  // NOTE: We don't use FirestoreError here because these are internal failures\n  // that cannot be handled by the user. (Also it would create a circular\n  // dependency between the error and assert modules which doesn't work.)\n  throw new Error(message);\n}\n\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n *\n * @param id - generate a new unique value with `yarn assertion-idgenerate`.\n * Search for an existing value using `yarn assertion-id:find X`\n */\nexport function hardAssert(\n  assertion: boolean,\n  id: number,\n  message: string,\n  context?: Record<string, unknown>\n): asserts assertion;\n\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n *\n * @param id - generate a new unique value with `yarn assertion-id:generate`.\n * Search for an existing value using `yarn assertion-id:find X`\n */\nexport function hardAssert(\n  assertion: boolean,\n  id: number,\n  context?: Record<string, unknown>\n): asserts assertion;\n\nexport function hardAssert(\n  assertion: boolean,\n  id: number,\n  messageOrContext?: string | Record<string, unknown>,\n  context?: Record<string, unknown>\n): asserts assertion {\n  let message = 'Unexpected state';\n  if (typeof messageOrContext === 'string') {\n    message = messageOrContext;\n  } else {\n    context = messageOrContext;\n  }\n\n  if (!assertion) {\n    _fail(id, message, context);\n  }\n}\n\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * The code of callsites invoking this function are stripped out in production\n * builds. Any side-effects of code within the debugAssert() invocation will not\n * happen in this case.\n *\n * @internal\n */\nexport function debugAssert(\n  assertion: boolean,\n  message: string\n): asserts assertion {\n  if (!assertion) {\n    fail(0xdeb6, message);\n  }\n}\n\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nexport function debugCast<T>(\n  obj: object,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor: { new (...args: any[]): T }\n): T | never {\n  debugAssert(\n    obj instanceof constructor,\n    `Expected type '${constructor.name}', but was '${obj.constructor.name}'`\n  );\n  return obj as T;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\n\n/**\n * The set of Firestore status codes. The codes are the same at the ones\n * exposed by gRPC here:\n * https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\n *\n * Possible values:\n * - 'cancelled': The operation was cancelled (typically by the caller).\n * - 'unknown': Unknown error or an error from a different error domain.\n * - 'invalid-argument': Client specified an invalid argument. Note that this\n *   differs from 'failed-precondition'. 'invalid-argument' indicates\n *   arguments that are problematic regardless of the state of the system\n *   (e.g. an invalid field name).\n * - 'deadline-exceeded': Deadline expired before operation could complete.\n *   For operations that change the state of the system, this error may be\n *   returned even if the operation has completed successfully. For example,\n *   a successful response from a server could have been delayed long enough\n *   for the deadline to expire.\n * - 'not-found': Some requested document was not found.\n * - 'already-exists': Some document that we attempted to create already\n *   exists.\n * - 'permission-denied': The caller does not have permission to execute the\n *   specified operation.\n * - 'resource-exhausted': Some resource has been exhausted, perhaps a\n *   per-user quota, or perhaps the entire file system is out of space.\n * - 'failed-precondition': Operation was rejected because the system is not\n *   in a state required for the operation's execution.\n * - 'aborted': The operation was aborted, typically due to a concurrency\n *   issue like transaction aborts, etc.\n * - 'out-of-range': Operation was attempted past the valid range.\n * - 'unimplemented': Operation is not implemented or not supported/enabled.\n * - 'internal': Internal errors. Means some invariants expected by\n *   underlying system has been broken. If you see one of these errors,\n *   something is very broken.\n * - 'unavailable': The service is currently unavailable. This is most likely\n *   a transient condition and may be corrected by retrying with a backoff.\n * - 'data-loss': Unrecoverable data loss or corruption.\n * - 'unauthenticated': The request does not have valid authentication\n *   credentials for the operation.\n */\nexport type FirestoreErrorCode =\n  | 'cancelled'\n  | 'unknown'\n  | 'invalid-argument'\n  | 'deadline-exceeded'\n  | 'not-found'\n  | 'already-exists'\n  | 'permission-denied'\n  | 'resource-exhausted'\n  | 'failed-precondition'\n  | 'aborted'\n  | 'out-of-range'\n  | 'unimplemented'\n  | 'internal'\n  | 'unavailable'\n  | 'data-loss'\n  | 'unauthenticated';\n\n/**\n * Error Codes describing the different ways Firestore can fail. These come\n * directly from GRPC.\n */\nexport type Code = FirestoreErrorCode;\n\nexport const Code = {\n  // Causes are copied from:\n  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n  /** Not an error; returned on success. */\n  OK: 'ok' as FirestoreErrorCode,\n\n  /** The operation was cancelled (typically by the caller). */\n  CANCELLED: 'cancelled' as FirestoreErrorCode,\n\n  /** Unknown error or an error from a different error domain. */\n  UNKNOWN: 'unknown' as FirestoreErrorCode,\n\n  /**\n   * Client specified an invalid argument. Note that this differs from\n   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n   * problematic regardless of the state of the system (e.g., a malformed file\n   * name).\n   */\n  INVALID_ARGUMENT: 'invalid-argument' as FirestoreErrorCode,\n\n  /**\n   * Deadline expired before operation could complete. For operations that\n   * change the state of the system, this error may be returned even if the\n   * operation has completed successfully. For example, a successful response\n   * from a server could have been delayed long enough for the deadline to\n   * expire.\n   */\n  DEADLINE_EXCEEDED: 'deadline-exceeded' as FirestoreErrorCode,\n\n  /** Some requested entity (e.g., file or directory) was not found. */\n  NOT_FOUND: 'not-found' as FirestoreErrorCode,\n\n  /**\n   * Some entity that we attempted to create (e.g., file or directory) already\n   * exists.\n   */\n  ALREADY_EXISTS: 'already-exists' as FirestoreErrorCode,\n\n  /**\n   * The caller does not have permission to execute the specified operation.\n   * PERMISSION_DENIED must not be used for rejections caused by exhausting\n   * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n   * PERMISSION_DENIED must not be used if the caller cannot be identified\n   * (use UNAUTHENTICATED instead for those errors).\n   */\n  PERMISSION_DENIED: 'permission-denied' as FirestoreErrorCode,\n\n  /**\n   * The request does not have valid authentication credentials for the\n   * operation.\n   */\n  UNAUTHENTICATED: 'unauthenticated' as FirestoreErrorCode,\n\n  /**\n   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n   * entire file system is out of space.\n   */\n  RESOURCE_EXHAUSTED: 'resource-exhausted' as FirestoreErrorCode,\n\n  /**\n   * Operation was rejected because the system is not in a state required for\n   * the operation's execution. For example, directory to be deleted may be\n   * non-empty, an rmdir operation is applied to a non-directory, etc.\n   *\n   * A litmus test that may help a service implementor in deciding\n   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n   *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n   *  (b) Use ABORTED if the client should retry at a higher-level\n   *      (e.g., restarting a read-modify-write sequence).\n   *  (c) Use FAILED_PRECONDITION if the client should not retry until\n   *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n   *      fails because the directory is non-empty, FAILED_PRECONDITION\n   *      should be returned since the client should not retry unless\n   *      they have first fixed up the directory by deleting files from it.\n   *  (d) Use FAILED_PRECONDITION if the client performs conditional\n   *      REST Get/Update/Delete on a resource and the resource on the\n   *      server does not match the condition. E.g., conflicting\n   *      read-modify-write on the same resource.\n   */\n  FAILED_PRECONDITION: 'failed-precondition' as FirestoreErrorCode,\n\n  /**\n   * The operation was aborted, typically due to a concurrency issue like\n   * sequencer check failures, transaction aborts, etc.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n   * and UNAVAILABLE.\n   */\n  ABORTED: 'aborted' as FirestoreErrorCode,\n\n  /**\n   * Operation was attempted past the valid range. E.g., seeking or reading\n   * past end of file.\n   *\n   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n   * if the system state changes. For example, a 32-bit file system will\n   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n   * an offset past the current file size.\n   *\n   * There is a fair bit of overlap between FAILED_PRECONDITION and\n   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n   * when it applies so that callers who are iterating through a space can\n   * easily look for an OUT_OF_RANGE error to detect when they are done.\n   */\n  OUT_OF_RANGE: 'out-of-range' as FirestoreErrorCode,\n\n  /** Operation is not implemented or not supported/enabled in this service. */\n  UNIMPLEMENTED: 'unimplemented' as FirestoreErrorCode,\n\n  /**\n   * Internal errors. Means some invariants expected by underlying System has\n   * been broken. If you see one of these errors, Something is very broken.\n   */\n  INTERNAL: 'internal' as FirestoreErrorCode,\n\n  /**\n   * The service is currently unavailable. This is a most likely a transient\n   * condition and may be corrected by retrying with a backoff.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n   * and UNAVAILABLE.\n   */\n  UNAVAILABLE: 'unavailable' as FirestoreErrorCode,\n\n  /** Unrecoverable data loss or corruption. */\n  DATA_LOSS: 'data-loss' as FirestoreErrorCode\n};\n\n/** An error returned by a Firestore operation. */\nexport class FirestoreError extends FirebaseError {\n  /** The stack of the error. */\n  readonly stack?: string;\n\n  /** @hideconstructor */\n  constructor(\n    /**\n     * The backend error code associated with this error.\n     */\n    readonly code: FirestoreErrorCode,\n    /**\n     * A custom error description.\n     */\n    readonly message: string\n  ) {\n    super(code, message);\n\n    // HACK: We write a toString property directly because Error is not a real\n    // class and so inheritance does not work correctly. We could alternatively\n    // do the same \"back-door inheritance\" trick that FirebaseError does.\n    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface Resolver<R> {\n  (value: R | Promise<R>): void;\n}\n\nexport interface Rejecter {\n  (reason?: Error): void;\n}\n\nexport class Deferred<R = void> {\n  promise: Promise<R>;\n  // Assigned synchronously in constructor by Promise constructor callback.\n  resolve!: Resolver<R>;\n  reject!: Rejecter;\n\n  constructor() {\n    this.promise = new Promise((resolve: Resolver<R>, reject: Rejecter) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n/**\n * Takes an array of values and a function from a value to a Promise. The function is run on each\n * value sequentially, waiting for the previous promise to resolve before starting the next one.\n * The returned promise resolves once the function has been run on all values.\n */\nexport function sequence<T>(\n  values: T[],\n  fn: (value: T) => Promise<void>\n): Promise<void> {\n  let p = Promise.resolve();\n  for (const value of values) {\n    p = p.then(() => fn(value));\n  }\n  return p;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, _isFirebaseServerApp } from '@firebase/app';\nimport {\n  AppCheckInternalComponentName,\n  AppCheckTokenListener,\n  AppCheckTokenResult,\n  FirebaseAppCheckInternal\n} from '@firebase/app-check-interop-types';\nimport {\n  FirebaseAuthInternal,\n  FirebaseAuthInternalName\n} from '@firebase/auth-interop-types';\nimport { Provider } from '@firebase/component';\n\nimport { User } from '../auth/user';\nimport { debugAssert, hardAssert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\nimport { Deferred } from '../util/promise';\n\n// TODO(mikelehen): This should be split into multiple files and probably\n// moved to an auth/ folder to match other platforms.\n\n/**\n * @internal\n */\nexport type AuthTokenFactory = () => string;\n\n/**\n * @internal\n */\nexport interface FirstPartyCredentialsSettings {\n  // These are external types. Prevent minification.\n  ['type']: 'firstParty';\n  ['sessionIndex']: string;\n  ['iamToken']: string | null;\n  ['authTokenFactory']: AuthTokenFactory | null;\n}\n\nexport interface ProviderCredentialsSettings {\n  // These are external types. Prevent minification.\n  ['type']: 'provider';\n  ['client']: CredentialsProvider<User>;\n}\n\n/** Settings for private credentials */\nexport type CredentialsSettings =\n  | FirstPartyCredentialsSettings\n  | ProviderCredentialsSettings;\n\nexport type TokenType = 'OAuth' | 'FirstParty' | 'AppCheck';\nexport interface Token {\n  /** Type of token. */\n  type: TokenType;\n\n  /**\n   * The user with which the token is associated (used for persisting user\n   * state on disk, etc.).\n   * This will be null for Tokens of the type 'AppCheck'.\n   */\n  user?: User;\n\n  /** Header values to set for this token */\n  headers: Map<string, string>;\n}\n\nexport class OAuthToken implements Token {\n  type = 'OAuth' as TokenType;\n  headers = new Map();\n\n  constructor(value: string, public user: User) {\n    this.headers.set('Authorization', `Bearer ${value}`);\n  }\n}\n\n/**\n * A Listener for credential change events. The listener should fetch a new\n * token and may need to invalidate other state if the current user has also\n * changed.\n */\nexport type CredentialChangeListener<T> = (credential: T) => Promise<void>;\n\n/**\n * Provides methods for getting the uid and token for the current user and\n * listening for changes.\n */\nexport interface CredentialsProvider<T> {\n  /**\n   * Starts the credentials provider and specifies a listener to be notified of\n   * credential changes (sign-in / sign-out, token changes). It is immediately\n   * called once with the initial user.\n   *\n   * The change listener is invoked on the provided AsyncQueue.\n   */\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<T>\n  ): void;\n\n  /** Requests a token for the current user. */\n  getToken(): Promise<Token | null>;\n\n  /**\n   * Marks the last retrieved token as invalid, making the next GetToken request\n   * force-refresh the token.\n   */\n  invalidateToken(): void;\n\n  shutdown(): void;\n}\n\n/**\n * A CredentialsProvider that always yields an empty token.\n * @internal\n */\nexport class EmptyAuthCredentialsProvider implements CredentialsProvider<User> {\n  getToken(): Promise<Token | null> {\n    return Promise.resolve<Token | null>(null);\n  }\n\n  invalidateToken(): void {}\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<User>\n  ): void {\n    // Fire with initial user.\n    asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\n  }\n\n  shutdown(): void {}\n}\n\n/**\n * A CredentialsProvider that always returns a constant token. Used for\n * emulator token mocking.\n */\nexport class EmulatorAuthCredentialsProvider\n  implements CredentialsProvider<User>\n{\n  constructor(private token: Token) {}\n\n  /**\n   * Stores the listener registered with setChangeListener()\n   * This isn't actually necessary since the UID never changes, but we use this\n   * to verify the listen contract is adhered to in tests.\n   */\n  private changeListener: CredentialChangeListener<User> | null = null;\n\n  getToken(): Promise<Token | null> {\n    return Promise.resolve(this.token);\n  }\n\n  invalidateToken(): void {}\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<User>\n  ): void {\n    debugAssert(\n      !this.changeListener,\n      'Can only call setChangeListener() once.'\n    );\n    this.changeListener = changeListener;\n    // Fire with initial user.\n    asyncQueue.enqueueRetryable(() => changeListener(this.token.user!));\n  }\n\n  shutdown(): void {\n    this.changeListener = null;\n  }\n}\n\n/** Credential provider for the Lite SDK. */\nexport class LiteAuthCredentialsProvider implements CredentialsProvider<User> {\n  private auth: FirebaseAuthInternal | null = null;\n\n  constructor(authProvider: Provider<FirebaseAuthInternalName>) {\n    authProvider.onInit(auth => {\n      this.auth = auth;\n    });\n  }\n\n  getToken(): Promise<Token | null> {\n    if (!this.auth) {\n      return Promise.resolve(null);\n    }\n\n    return this.auth.getToken().then(tokenData => {\n      if (tokenData) {\n        hardAssert(\n          typeof tokenData.accessToken === 'string',\n          0xa539,\n          'Invalid tokenData returned from getToken()',\n          { tokenData }\n        );\n        return new OAuthToken(\n          tokenData.accessToken,\n          new User(this.auth!.getUid())\n        );\n      } else {\n        return null;\n      }\n    });\n  }\n\n  invalidateToken(): void {}\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<User>\n  ): void {}\n\n  shutdown(): void {}\n}\n\nexport class FirebaseAuthCredentialsProvider\n  implements CredentialsProvider<User>\n{\n  /**\n   * The auth token listener registered with FirebaseApp, retained here so we\n   * can unregister it.\n   */\n  private tokenListener: (() => void) | undefined;\n\n  /** Tracks the current User. */\n  private currentUser: User = User.UNAUTHENTICATED;\n\n  /**\n   * Counter used to detect if the token changed while a getToken request was\n   * outstanding.\n   */\n  private tokenCounter = 0;\n\n  private forceRefresh = false;\n\n  private auth: FirebaseAuthInternal | null = null;\n\n  constructor(private authProvider: Provider<FirebaseAuthInternalName>) {}\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<User>\n  ): void {\n    hardAssert(\n      this.tokenListener === undefined,\n      0xa540,\n      'Token listener already added'\n    );\n    let lastTokenId = this.tokenCounter;\n\n    // A change listener that prevents double-firing for the same token change.\n    const guardedChangeListener: (user: User) => Promise<void> = user => {\n      if (this.tokenCounter !== lastTokenId) {\n        lastTokenId = this.tokenCounter;\n        return changeListener(user);\n      } else {\n        return Promise.resolve();\n      }\n    };\n\n    // A promise that can be waited on to block on the next token change.\n    // This promise is re-created after each change.\n    let nextToken = new Deferred<void>();\n\n    this.tokenListener = () => {\n      this.tokenCounter++;\n      this.currentUser = this.getUser();\n      nextToken.resolve();\n      nextToken = new Deferred<void>();\n      asyncQueue.enqueueRetryable(() =>\n        guardedChangeListener(this.currentUser)\n      );\n    };\n\n    const awaitNextToken: () => void = () => {\n      const currentTokenAttempt = nextToken;\n      asyncQueue.enqueueRetryable(async () => {\n        await currentTokenAttempt.promise;\n        await guardedChangeListener(this.currentUser);\n      });\n    };\n\n    const registerAuth = (auth: FirebaseAuthInternal): void => {\n      logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\n      this.auth = auth;\n      if (this.tokenListener) {\n        this.auth.addAuthTokenListener(this.tokenListener);\n        awaitNextToken();\n      }\n    };\n\n    this.authProvider.onInit(auth => registerAuth(auth));\n\n    // Our users can initialize Auth right after Firestore, so we give it\n    // a chance to register itself with the component framework before we\n    // determine whether to start up in unauthenticated mode.\n    setTimeout(() => {\n      if (!this.auth) {\n        const auth = this.authProvider.getImmediate({ optional: true });\n        if (auth) {\n          registerAuth(auth);\n        } else {\n          // If auth is still not available, proceed with `null` user\n          logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\n          nextToken.resolve();\n          nextToken = new Deferred<void>();\n        }\n      }\n    }, 0);\n\n    awaitNextToken();\n  }\n\n  getToken(): Promise<Token | null> {\n    debugAssert(\n      this.tokenListener != null,\n      'FirebaseAuthCredentialsProvider not started.'\n    );\n\n    // Take note of the current value of the tokenCounter so that this method\n    // can fail (with an ABORTED error) if there is a token change while the\n    // request is outstanding.\n    const initialTokenCounter = this.tokenCounter;\n    const forceRefresh = this.forceRefresh;\n    this.forceRefresh = false;\n\n    if (!this.auth) {\n      return Promise.resolve(null);\n    }\n\n    return this.auth.getToken(forceRefresh).then(tokenData => {\n      // Cancel the request since the token changed while the request was\n      // outstanding so the response is potentially for a previous user (which\n      // user, we can't be sure).\n      if (this.tokenCounter !== initialTokenCounter) {\n        logDebug(\n          'FirebaseAuthCredentialsProvider',\n          'getToken aborted due to token change.'\n        );\n        return this.getToken();\n      } else {\n        if (tokenData) {\n          hardAssert(\n            typeof tokenData.accessToken === 'string',\n            0x7c5d,\n            'Invalid tokenData returned from getToken()',\n            { tokenData }\n          );\n          return new OAuthToken(tokenData.accessToken, this.currentUser);\n        } else {\n          return null;\n        }\n      }\n    });\n  }\n\n  invalidateToken(): void {\n    this.forceRefresh = true;\n  }\n\n  shutdown(): void {\n    if (this.auth && this.tokenListener) {\n      this.auth.removeAuthTokenListener(this.tokenListener);\n    }\n    this.tokenListener = undefined;\n  }\n\n  // Auth.getUid() can return null even with a user logged in. It is because\n  // getUid() is synchronous, but the auth code populating Uid is asynchronous.\n  // This method should only be called in the AuthTokenListener callback\n  // to guarantee to get the actual user.\n  private getUser(): User {\n    const currentUid = this.auth && this.auth.getUid();\n    hardAssert(\n      currentUid === null || typeof currentUid === 'string',\n      0x0807,\n      'Received invalid UID',\n      { currentUid }\n    );\n    return new User(currentUid);\n  }\n}\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nexport class FirstPartyToken implements Token {\n  type = 'FirstParty' as TokenType;\n  user = User.FIRST_PARTY;\n  private _headers = new Map();\n\n  constructor(\n    private readonly sessionIndex: string,\n    private readonly iamToken: string | null,\n    private readonly authTokenFactory: AuthTokenFactory | null\n  ) {}\n\n  /**\n   * Gets an authorization token, using a provided factory function, or return\n   * null.\n   */\n  private getAuthToken(): string | null {\n    if (this.authTokenFactory) {\n      return this.authTokenFactory();\n    } else {\n      return null;\n    }\n  }\n\n  get headers(): Map<string, string> {\n    this._headers.set('X-Goog-AuthUser', this.sessionIndex);\n    // Use array notation to prevent minification\n    const authHeaderTokenValue = this.getAuthToken();\n    if (authHeaderTokenValue) {\n      this._headers.set('Authorization', authHeaderTokenValue);\n    }\n    if (this.iamToken) {\n      this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\n    }\n\n    return this._headers;\n  }\n}\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nexport class FirstPartyAuthCredentialsProvider\n  implements CredentialsProvider<User>\n{\n  constructor(\n    private sessionIndex: string,\n    private iamToken: string | null,\n    private authTokenFactory: AuthTokenFactory | null\n  ) {}\n\n  getToken(): Promise<Token | null> {\n    return Promise.resolve(\n      new FirstPartyToken(\n        this.sessionIndex,\n        this.iamToken,\n        this.authTokenFactory\n      )\n    );\n  }\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<User>\n  ): void {\n    // Fire with initial uid.\n    asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\n  }\n\n  shutdown(): void {}\n\n  invalidateToken(): void {}\n}\n\nexport class AppCheckToken implements Token {\n  type = 'AppCheck' as TokenType;\n  headers = new Map();\n\n  constructor(private value: string) {\n    if (value && value.length > 0) {\n      this.headers.set('x-firebase-appcheck', this.value);\n    }\n  }\n}\n\nexport class FirebaseAppCheckTokenProvider\n  implements CredentialsProvider<string>\n{\n  /**\n   * The AppCheck token listener registered with FirebaseApp, retained here so\n   * we can unregister it.\n   */\n  private tokenListener: AppCheckTokenListener | undefined;\n  private forceRefresh = false;\n  private appCheck: FirebaseAppCheckInternal | null = null;\n  private latestAppCheckToken: string | null = null;\n  private serverAppAppCheckToken: string | null = null;\n\n  constructor(\n    app: FirebaseApp,\n    private appCheckProvider: Provider<AppCheckInternalComponentName>\n  ) {\n    if (_isFirebaseServerApp(app) && app.settings.appCheckToken) {\n      this.serverAppAppCheckToken = app.settings.appCheckToken;\n    }\n  }\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<string>\n  ): void {\n    hardAssert(\n      this.tokenListener === undefined,\n      0x0db8,\n      'Token listener already added'\n    );\n\n    const onTokenChanged: (\n      tokenResult: AppCheckTokenResult\n    ) => Promise<void> = tokenResult => {\n      if (tokenResult.error != null) {\n        logDebug(\n          'FirebaseAppCheckTokenProvider',\n          `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`\n        );\n      }\n      const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\n      this.latestAppCheckToken = tokenResult.token;\n      logDebug(\n        'FirebaseAppCheckTokenProvider',\n        `Received ${tokenUpdated ? 'new' : 'existing'} token.`\n      );\n      return tokenUpdated\n        ? changeListener(tokenResult.token)\n        : Promise.resolve();\n    };\n\n    this.tokenListener = (tokenResult: AppCheckTokenResult) => {\n      asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\n    };\n\n    const registerAppCheck = (appCheck: FirebaseAppCheckInternal): void => {\n      logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\n      this.appCheck = appCheck;\n      if (this.tokenListener) {\n        this.appCheck.addTokenListener(this.tokenListener);\n      }\n    };\n\n    this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\n\n    // Our users can initialize AppCheck after Firestore, so we give it\n    // a chance to register itself with the component framework.\n    setTimeout(() => {\n      if (!this.appCheck) {\n        const appCheck = this.appCheckProvider.getImmediate({ optional: true });\n        if (appCheck) {\n          registerAppCheck(appCheck);\n        } else {\n          // If AppCheck is still not available, proceed without it.\n          logDebug(\n            'FirebaseAppCheckTokenProvider',\n            'AppCheck not yet detected'\n          );\n        }\n      }\n    }, 0);\n  }\n\n  getToken(): Promise<Token | null> {\n    if (this.serverAppAppCheckToken) {\n      return Promise.resolve(new AppCheckToken(this.serverAppAppCheckToken));\n    }\n    debugAssert(\n      this.tokenListener != null,\n      'FirebaseAppCheckTokenProvider not started.'\n    );\n\n    const forceRefresh = this.forceRefresh;\n    this.forceRefresh = false;\n\n    if (!this.appCheck) {\n      return Promise.resolve(null);\n    }\n\n    return this.appCheck.getToken(forceRefresh).then(tokenResult => {\n      if (tokenResult) {\n        hardAssert(\n          typeof tokenResult.token === 'string',\n          0xae0e,\n          'Invalid tokenResult returned from getToken()',\n          { tokenResult }\n        );\n        this.latestAppCheckToken = tokenResult.token;\n        return new AppCheckToken(tokenResult.token);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  invalidateToken(): void {\n    this.forceRefresh = true;\n  }\n\n  shutdown(): void {\n    if (this.appCheck && this.tokenListener) {\n      this.appCheck.removeTokenListener(this.tokenListener);\n    }\n    this.tokenListener = undefined;\n  }\n}\n\n/**\n * An AppCheck token provider that always yields an empty token.\n * @internal\n */\nexport class EmptyAppCheckTokenProvider implements CredentialsProvider<string> {\n  getToken(): Promise<Token | null> {\n    return Promise.resolve<Token | null>(new AppCheckToken(''));\n  }\n\n  invalidateToken(): void {}\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<string>\n  ): void {}\n\n  shutdown(): void {}\n}\n\n/** AppCheck token provider for the Lite SDK. */\nexport class LiteAppCheckTokenProvider implements CredentialsProvider<string> {\n  private appCheck: FirebaseAppCheckInternal | null = null;\n  private serverAppAppCheckToken: string | null = null;\n\n  constructor(\n    app: FirebaseApp,\n    private appCheckProvider: Provider<AppCheckInternalComponentName>\n  ) {\n    if (_isFirebaseServerApp(app) && app.settings.appCheckToken) {\n      this.serverAppAppCheckToken = app.settings.appCheckToken;\n    }\n    appCheckProvider.onInit(appCheck => {\n      this.appCheck = appCheck;\n    });\n  }\n\n  getToken(): Promise<Token | null> {\n    if (this.serverAppAppCheckToken) {\n      return Promise.resolve(new AppCheckToken(this.serverAppAppCheckToken));\n    }\n\n    if (!this.appCheck) {\n      return Promise.resolve(null);\n    }\n\n    return this.appCheck.getToken().then(tokenResult => {\n      if (tokenResult) {\n        hardAssert(\n          typeof tokenResult.token === 'string',\n          0x0d8e,\n          'Invalid tokenResult returned from getToken()',\n          { tokenResult }\n        );\n        return new AppCheckToken(tokenResult.token);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  invalidateToken(): void {}\n\n  start(\n    asyncQueue: AsyncQueue,\n    changeListener: CredentialChangeListener<string>\n  ): void {}\n\n  shutdown(): void {}\n}\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeAuthCredentialsProvider(\n  credentials?: CredentialsSettings\n): CredentialsProvider<User> {\n  if (!credentials) {\n    return new EmptyAuthCredentialsProvider();\n  }\n  switch (credentials['type']) {\n    case 'firstParty':\n      return new FirstPartyAuthCredentialsProvider(\n        credentials['sessionIndex'] || '0',\n        credentials['iamToken'] || null,\n        credentials['authTokenFactory'] || null\n      );\n\n    case 'provider':\n      return credentials['client'];\n\n    default:\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'makeAuthCredentialsProvider failed due to invalid credential type'\n      );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from '../../util/assert';\n\n/**\n * Generates `nBytes` of random bytes.\n *\n * If `nBytes < 0` , an error will be thrown.\n */\nexport function randomBytes(nBytes: number): Uint8Array {\n  debugAssert(nBytes >= 0, `Expecting non-negative nBytes, got: ${nBytes}`);\n\n  // Polyfills for IE and WebWorker by using `self` and `msCrypto` when `crypto` is not available.\n  const crypto =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof self !== 'undefined' && (self.crypto || (self as any)['msCrypto']);\n  const bytes = new Uint8Array(nBytes);\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Falls back to Math.random\n    for (let i = 0; i < nBytes; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return bytes;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { randomBytes } from '../platform/random_bytes';\n\nimport { debugAssert } from './assert';\n\nexport type EventHandler<E> = (value: E) => void;\nexport interface Indexable {\n  [k: string]: unknown;\n}\n\n/**\n * A utility class for generating unique alphanumeric IDs of a specified length.\n *\n * @internal\n * Exported internally for testing purposes.\n */\nexport class AutoId {\n  static newId(): string {\n    // Alphanumeric characters\n    const chars =\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    // The largest byte value that is a multiple of `char.length`.\n    const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n    debugAssert(\n      0 < maxMultiple && maxMultiple < 256,\n      `Expect maxMultiple to be (0, 256), but got ${maxMultiple}`\n    );\n\n    let autoId = '';\n    const targetLength = 20;\n    while (autoId.length < targetLength) {\n      const bytes = randomBytes(40);\n      for (let i = 0; i < bytes.length; ++i) {\n        // Only accept values that are [0, maxMultiple), this ensures they can\n        // be evenly mapped to indices of `chars` via a modulo operation.\n        if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n          autoId += chars.charAt(bytes[i] % chars.length);\n        }\n      }\n    }\n    debugAssert(autoId.length === targetLength, 'Invalid auto ID: ' + autoId);\n\n    return autoId;\n  }\n}\n\nexport function primitiveComparator<T>(left: T, right: T): number {\n  if (left < right) {\n    return -1;\n  }\n  if (left > right) {\n    return 1;\n  }\n  return 0;\n}\n\nexport interface Equatable<T> {\n  isEqual(other: T): boolean;\n}\n\n/** Compare strings in UTF-8 encoded byte order */\nexport function compareUtf8Strings(left: string, right: string): number {\n  // Find the first differing character (a.k.a. \"UTF-16 code unit\") in the two strings and,\n  // if found, use that character to determine the relative ordering of the two strings as a\n  // whole. Comparing UTF-16 strings in UTF-8 byte order can be done simply and efficiently by\n  // comparing the UTF-16 code units (chars). This serendipitously works because of the way UTF-8\n  // and UTF-16 happen to represent Unicode code points.\n  //\n  // After finding the first pair of differing characters, there are two cases:\n  //\n  // Case 1: Both characters are non-surrogates (code points less than or equal to 0xFFFF) or\n  // both are surrogates from a surrogate pair (that collectively represent code points greater\n  // than 0xFFFF). In this case their numeric order as UTF-16 code units is the same as the\n  // lexicographical order of their corresponding UTF-8 byte sequences. A direct comparison is\n  // sufficient.\n  //\n  // Case 2: One character is a surrogate and the other is not. In this case the surrogate-\n  // containing string is always ordered after the non-surrogate. This is because surrogates are\n  // used to represent code points greater than 0xFFFF which have 4-byte UTF-8 representations\n  // and are lexicographically greater than the 1, 2, or 3-byte representations of code points\n  // less than or equal to 0xFFFF.\n  //\n  // An example of why Case 2 is required is comparing the following two Unicode code points:\n  //\n  // |-----------------------|------------|---------------------|-----------------|\n  // | Name                  | Code Point | UTF-8 Encoding      | UTF-16 Encoding |\n  // |-----------------------|------------|---------------------|-----------------|\n  // | Replacement Character | U+FFFD     | 0xEF 0xBF 0xBD      | 0xFFFD          |\n  // | Grinning Face         | U+1F600    | 0xF0 0x9F 0x98 0x80 | 0xD83D 0xDE00   |\n  // |-----------------------|------------|---------------------|-----------------|\n  //\n  // A lexicographical comparison of the UTF-8 encodings of these code points would order\n  // \"Replacement Character\" _before_ \"Grinning Face\" because 0xEF is less than 0xF0. However, a\n  // direct comparison of the UTF-16 code units, as would be done in case 1, would erroneously\n  // produce the _opposite_ ordering, because 0xFFFD is _greater than_ 0xD83D. As it turns out,\n  // this relative ordering holds for all comparisons of UTF-16 code points requiring a surrogate\n  // pair with those that do not.\n  const length = Math.min(left.length, right.length);\n  for (let i = 0; i < length; i++) {\n    const leftChar = left.charAt(i);\n    const rightChar = right.charAt(i);\n    if (leftChar !== rightChar) {\n      return isSurrogate(leftChar) === isSurrogate(rightChar)\n        ? primitiveComparator(leftChar, rightChar)\n        : isSurrogate(leftChar)\n        ? 1\n        : -1;\n    }\n  }\n\n  // Use the lengths of the strings to determine the overall comparison result since either the\n  // strings were equal or one is a prefix of the other.\n  return primitiveComparator(left.length, right.length);\n}\n\nconst MIN_SURROGATE = 0xd800;\nconst MAX_SURROGATE = 0xdfff;\n\nexport function isSurrogate(s: string): boolean {\n  debugAssert(s.length === 1, `s.length == ${s.length}, but expected 1`);\n  const c = s.charCodeAt(0);\n  return c >= MIN_SURROGATE && c <= MAX_SURROGATE;\n}\n\nexport interface Iterable<V> {\n  forEach: (cb: (v: V) => void) => void;\n}\n\n/** Helper to compare arrays using isEqual(). */\nexport function arrayEquals<T>(\n  left: T[],\n  right: T[],\n  comparator: (l: T, r: T) => boolean\n): boolean {\n  if (left.length !== right.length) {\n    return false;\n  }\n  return left.every((value, index) => comparator(value, right[index]));\n}\n\n/**\n * Verifies equality for an optional value.\n */\nexport function isOptionalEqual<T>(\n  left: T | undefined,\n  right: T | undefined,\n  equalityTest: (left: T, right: T) => boolean\n): boolean {\n  if (left === undefined && right === undefined) {\n    return true;\n  }\n\n  if (left === undefined || right === undefined) {\n    return false;\n  }\n\n  return equalityTest(left, right);\n}\n\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s: string): string {\n  // Return the input string, with an additional NUL byte appended.\n  return s + '\\0';\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Integer } from '@firebase/webchannel-wrapper/bloom-blob';\n\nimport { debugAssert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { compareUtf8Strings, primitiveComparator } from '../util/misc';\n\nexport const DOCUMENT_KEY_NAME = '__name__';\n\n/**\n * Path represents an ordered sequence of string segments.\n */\nabstract class BasePath<B extends BasePath<B>> {\n  private segments: string[];\n  private offset: number;\n  private len: number;\n\n  constructor(segments: string[], offset?: number, length?: number) {\n    if (offset === undefined) {\n      offset = 0;\n    } else if (offset > segments.length) {\n      fail(0x027d, 'offset out of range', {\n        offset,\n        range: segments.length\n      });\n    }\n\n    if (length === undefined) {\n      length = segments.length - offset;\n    } else if (length > segments.length - offset) {\n      fail(0x06d2, 'length out of range', {\n        length,\n        range: segments.length - offset\n      });\n    }\n    this.segments = segments;\n    this.offset = offset;\n    this.len = length;\n  }\n\n  /**\n   * Abstract constructor method to construct an instance of B with the given\n   * parameters.\n   */\n  protected abstract construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): B;\n\n  /**\n   * Returns a String representation.\n   *\n   * Implementing classes are required to provide deterministic implementations as\n   * the String representation is used to obtain canonical Query IDs.\n   */\n  abstract toString(): string;\n\n  get length(): number {\n    return this.len;\n  }\n\n  isEqual(other: B): boolean {\n    return BasePath.comparator(this, other) === 0;\n  }\n\n  child(nameOrPath: string | B): B {\n    const segments = this.segments.slice(this.offset, this.limit());\n    if (nameOrPath instanceof BasePath) {\n      nameOrPath.forEach(segment => {\n        segments.push(segment);\n      });\n    } else {\n      segments.push(nameOrPath);\n    }\n    return this.construct(segments);\n  }\n\n  /** The index of one past the last segment of the path. */\n  private limit(): number {\n    return this.offset + this.length;\n  }\n\n  popFirst(size?: number): B {\n    size = size === undefined ? 1 : size;\n    debugAssert(\n      this.length >= size,\n      \"Can't call popFirst() with less segments\"\n    );\n    return this.construct(\n      this.segments,\n      this.offset + size,\n      this.length - size\n    );\n  }\n\n  popLast(): B {\n    debugAssert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n    return this.construct(this.segments, this.offset, this.length - 1);\n  }\n\n  firstSegment(): string {\n    debugAssert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n    return this.segments[this.offset];\n  }\n\n  lastSegment(): string {\n    debugAssert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n    return this.get(this.length - 1);\n  }\n\n  get(index: number): string {\n    debugAssert(index < this.length, 'Index out of range');\n    return this.segments[this.offset + index];\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  isPrefixOf(other: this): boolean {\n    if (other.length < this.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== other.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  isImmediateParentOf(potentialChild: this): boolean {\n    if (this.length + 1 !== potentialChild.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== potentialChild.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  forEach(fn: (segment: string) => void): void {\n    for (let i = this.offset, end = this.limit(); i < end; i++) {\n      fn(this.segments[i]);\n    }\n  }\n\n  toArray(): string[] {\n    return this.segments.slice(this.offset, this.limit());\n  }\n\n  /**\n   * Compare 2 paths segment by segment, prioritizing numeric IDs\n   * (e.g., \"__id123__\") in numeric ascending order, followed by string\n   * segments in lexicographical order.\n   */\n  static comparator<T extends BasePath<T>>(\n    p1: BasePath<T>,\n    p2: BasePath<T>\n  ): number {\n    const len = Math.min(p1.length, p2.length);\n    for (let i = 0; i < len; i++) {\n      const comparison = BasePath.compareSegments(p1.get(i), p2.get(i));\n      if (comparison !== 0) {\n        return comparison;\n      }\n    }\n    return primitiveComparator(p1.length, p2.length);\n  }\n\n  private static compareSegments(lhs: string, rhs: string): number {\n    const isLhsNumeric = BasePath.isNumericId(lhs);\n    const isRhsNumeric = BasePath.isNumericId(rhs);\n\n    if (isLhsNumeric && !isRhsNumeric) {\n      // Only lhs is numeric\n      return -1;\n    } else if (!isLhsNumeric && isRhsNumeric) {\n      // Only rhs is numeric\n      return 1;\n    } else if (isLhsNumeric && isRhsNumeric) {\n      // both numeric\n      return BasePath.extractNumericId(lhs).compare(\n        BasePath.extractNumericId(rhs)\n      );\n    } else {\n      // both non-numeric\n      return compareUtf8Strings(lhs, rhs);\n    }\n  }\n\n  // Checks if a segment is a numeric ID (starts with \"__id\" and ends with \"__\").\n  private static isNumericId(segment: string): boolean {\n    return segment.startsWith('__id') && segment.endsWith('__');\n  }\n\n  private static extractNumericId(segment: string): Integer {\n    return Integer.fromString(segment.substring(4, segment.length - 2));\n  }\n}\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n *\n * @internal\n */\nexport class ResourcePath extends BasePath<ResourcePath> {\n  protected construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): ResourcePath {\n    return new ResourcePath(segments, offset, length);\n  }\n\n  canonicalString(): string {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    return this.toArray().join('/');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Returns a string representation of this path\n   * where each path segment has been encoded with\n   * `encodeURIComponent`.\n   */\n  toUriEncodedString(): string {\n    return this.toArray().map(encodeURIComponent).join('/');\n  }\n\n  /**\n   * Creates a resource path from the given slash-delimited string. If multiple\n   * arguments are provided, all components are combined. Leading and trailing\n   * slashes from all components are ignored.\n   */\n  static fromString(...pathComponents: string[]): ResourcePath {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    const segments: string[] = [];\n    for (const path of pathComponents) {\n      if (path.indexOf('//') >= 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid segment (${path}). Paths must not contain // in them.`\n        );\n      }\n      // Strip leading and trailing slashed.\n      segments.push(...path.split('/').filter(segment => segment.length > 0));\n    }\n\n    return new ResourcePath(segments);\n  }\n\n  static emptyPath(): ResourcePath {\n    return new ResourcePath([]);\n  }\n}\n\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n/**\n * A dot-separated path for navigating sub-objects within a document.\n * @internal\n */\nexport class FieldPath extends BasePath<FieldPath> {\n  protected construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): FieldPath {\n    return new FieldPath(segments, offset, length);\n  }\n\n  /**\n   * Returns true if the string could be used as a segment in a field path\n   * without escaping.\n   */\n  private static isValidIdentifier(segment: string): boolean {\n    return identifierRegExp.test(segment);\n  }\n\n  canonicalString(): string {\n    return this.toArray()\n      .map(str => {\n        str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\n        if (!FieldPath.isValidIdentifier(str)) {\n          str = '`' + str + '`';\n        }\n        return str;\n      })\n      .join('.');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Returns true if this field references the key of a document.\n   */\n  isKeyField(): boolean {\n    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n  }\n\n  /**\n   * The field designating the key of a document.\n   */\n  static keyField(): FieldPath {\n    return new FieldPath([DOCUMENT_KEY_NAME]);\n  }\n\n  /**\n   * Parses a field string from the given server-formatted string.\n   *\n   * - Splitting the empty string is not allowed (for now at least).\n   * - Empty segments within the string (e.g. if there are two consecutive\n   *   separators) are not allowed.\n   *\n   * TODO(b/37244157): we should make this more strict. Right now, it allows\n   * non-identifier path components, even if they aren't escaped.\n   */\n  static fromServerFormat(path: string): FieldPath {\n    const segments: string[] = [];\n    let current = '';\n    let i = 0;\n\n    const addCurrentSegment = (): void => {\n      if (current.length === 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid field path (${path}). Paths must not be empty, begin ` +\n            `with '.', end with '.', or contain '..'`\n        );\n      }\n      segments.push(current);\n      current = '';\n    };\n\n    let inBackticks = false;\n\n    while (i < path.length) {\n      const c = path[i];\n      if (c === '\\\\') {\n        if (i + 1 === path.length) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has trailing escape character: ' + path\n          );\n        }\n        const next = path[i + 1];\n        if (!(next === '\\\\' || next === '.' || next === '`')) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has invalid escape sequence: ' + path\n          );\n        }\n        current += next;\n        i += 2;\n      } else if (c === '`') {\n        inBackticks = !inBackticks;\n        i++;\n      } else if (c === '.' && !inBackticks) {\n        addCurrentSegment();\n        i++;\n      } else {\n        current += c;\n        i++;\n      }\n    }\n    addCurrentSegment();\n\n    if (inBackticks) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Unterminated ` in path: ' + path\n      );\n    }\n\n    return new FieldPath(segments);\n  }\n\n  static emptyPath(): FieldPath {\n    return new FieldPath([]);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from '../util/assert';\n\nimport { ResourcePath } from './path';\n\n/**\n * @internal\n */\nexport class DocumentKey {\n  constructor(readonly path: ResourcePath) {\n    debugAssert(\n      DocumentKey.isDocumentKey(path),\n      'Invalid DocumentKey with an odd number of segments: ' +\n        path.toArray().join('/')\n    );\n  }\n\n  static fromPath(path: string): DocumentKey {\n    return new DocumentKey(ResourcePath.fromString(path));\n  }\n\n  static fromName(name: string): DocumentKey {\n    return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n  }\n\n  static empty(): DocumentKey {\n    return new DocumentKey(ResourcePath.emptyPath());\n  }\n\n  get collectionGroup(): string {\n    debugAssert(\n      !this.path.isEmpty(),\n      'Cannot get collection group for empty key'\n    );\n    return this.path.popLast().lastSegment();\n  }\n\n  /** Returns true if the document is in the specified collectionId. */\n  hasCollectionId(collectionId: string): boolean {\n    return (\n      this.path.length >= 2 &&\n      this.path.get(this.path.length - 2) === collectionId\n    );\n  }\n\n  /** Returns the collection group (i.e. the name of the parent collection) for this key. */\n  getCollectionGroup(): string {\n    debugAssert(\n      !this.path.isEmpty(),\n      'Cannot get collection group for empty key'\n    );\n    return this.path.get(this.path.length - 2);\n  }\n\n  /** Returns the fully qualified path to the parent collection. */\n  getCollectionPath(): ResourcePath {\n    return this.path.popLast();\n  }\n\n  isEqual(other: DocumentKey | null): boolean {\n    return (\n      other !== null && ResourcePath.comparator(this.path, other.path) === 0\n    );\n  }\n\n  toString(): string {\n    return this.path.toString();\n  }\n\n  static comparator(k1: DocumentKey, k2: DocumentKey): number {\n    return ResourcePath.comparator(k1.path, k2.path);\n  }\n\n  static isDocumentKey(path: ResourcePath): boolean {\n    return path.length % 2 === 0;\n  }\n\n  /**\n   * Creates and returns a new document key with the given segments.\n   *\n   * @param segments - The segments of the path to the document\n   * @returns A new instance of DocumentKey\n   */\n  static fromSegments(segments: string[]): DocumentKey {\n    return new DocumentKey(new ResourcePath(segments.slice()));\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentData } from '../lite-api/reference';\nimport { DocumentKey } from '../model/document_key';\nimport { ResourcePath } from '../model/path';\n\nimport { fail } from './assert';\nimport { Code, FirestoreError } from './error';\n\n/** Types accepted by validateType() and related methods for validation. */\nexport type ValidationType =\n  | 'undefined'\n  | 'object'\n  | 'function'\n  | 'boolean'\n  | 'number'\n  | 'string'\n  | 'non-empty string';\n\nexport function validateNonEmptyArgument(\n  functionName: string,\n  argumentName: string,\n  argument?: string\n): asserts argument is string {\n  if (!argument) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() cannot be called with an empty ${argumentName}.`\n    );\n  }\n}\n\n/**\n * Validates that two boolean options are not set at the same time.\n * @internal\n */\nexport function validateIsNotUsedTogether(\n  optionName1: string,\n  argument1: boolean | undefined,\n  optionName2: string,\n  argument2: boolean | undefined\n): void {\n  if (argument1 === true && argument2 === true) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `${optionName1} and ${optionName2} cannot be used together.`\n    );\n  }\n}\n\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nexport function validateDocumentPath(path: ResourcePath): void {\n  if (!DocumentKey.isDocumentKey(path)) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`\n    );\n  }\n}\n\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nexport function validateCollectionPath(path: ResourcePath): void {\n  if (DocumentKey.isDocumentKey(path)) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`\n    );\n  }\n}\n\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nexport function isPlainObject(input: unknown): input is DocumentData {\n  return (\n    typeof input === 'object' &&\n    input !== null &&\n    (Object.getPrototypeOf(input) === Object.prototype ||\n      Object.getPrototypeOf(input) === null)\n  );\n}\n\n/** Returns a string describing the type / value of the provided input. */\nexport function valueDescription(input: unknown): string {\n  if (input === undefined) {\n    return 'undefined';\n  } else if (input === null) {\n    return 'null';\n  } else if (typeof input === 'string') {\n    if (input.length > 20) {\n      input = `${input.substring(0, 20)}...`;\n    }\n    return JSON.stringify(input);\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return '' + input;\n  } else if (typeof input === 'object') {\n    if (input instanceof Array) {\n      return 'an array';\n    } else {\n      const customObjectName = tryGetCustomObjectType(input!);\n      if (customObjectName) {\n        return `a custom ${customObjectName} object`;\n      } else {\n        return 'an object';\n      }\n    }\n  } else if (typeof input === 'function') {\n    return 'a function';\n  } else {\n    return fail(0x3029, 'Unknown wrong type', { type: typeof input });\n  }\n}\n\n/** try to get the constructor name for an object. */\nexport function tryGetCustomObjectType(input: object): string | null {\n  if (input.constructor) {\n    return input.constructor.name;\n  }\n  return null;\n}\n\n/**\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\n * underlying instance. Throws if  `obj` is not an instance of `T`.\n *\n * This cast is used in the Lite and Full SDK to verify instance types for\n * arguments passed to the public API.\n * @internal\n */\nexport function cast<T>(\n  obj: object,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor: { new (...args: any[]): T }\n): T | never {\n  if ('_delegate' in obj) {\n    // Unwrap Compat types\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    obj = (obj as any)._delegate;\n  }\n\n  if (!(obj instanceof constructor)) {\n    if (constructor.name === obj.constructor.name) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Type does not match the expected instance. Did you pass a ' +\n          `reference from a different Firestore SDK?`\n      );\n    } else {\n      const description = valueDescription(obj);\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Expected type '${constructor.name}', but it was: ${description}`\n      );\n    }\n  }\n  return obj as T;\n}\n\nexport function validatePositiveNumber(functionName: string, n: number): void {\n  if (n <= 0) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires a positive number, but it was: ${n}.`\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isPlainObject } from '../util/input_validation';\n\nimport { Code, FirestoreError } from './error';\n\n/**\n * A list of data types Firestore objects may serialize in their toJSON implemenetations.\n * @private\n * @internal\n */\nexport type JsonTypeDesc =\n  | 'object'\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'null'\n  | 'undefined';\n\n/**\n * An association of JsonTypeDesc values to their native types.\n * @private\n * @internal\n */\nexport type TSType<T extends JsonTypeDesc> = T extends 'object'\n  ? object\n  : T extends 'string'\n  ? string\n  : T extends 'number'\n  ? number\n  : T extends 'boolean'\n  ? boolean\n  : T extends 'null'\n  ? null\n  : T extends 'undefined'\n  ? undefined\n  : never;\n\n/**\n * The representation of a JSON object property name and its type value.\n * @private\n * @internal\n */\nexport interface Property<T extends JsonTypeDesc> {\n  value?: TSType<T>;\n  typeString: JsonTypeDesc;\n}\n\n/**\n * A type Firestore data types may use to define the fields used in their JSON serialization.\n * @private\n * @internal\n */\nexport interface JsonSchema {\n  [key: string]: Property<JsonTypeDesc>;\n}\n\n/**\n * Associates the JSON property type to the native type and sets them to be Required.\n * @private\n * @internal\n */\nexport type Json<T extends JsonSchema> = {\n  [K in keyof T]: Required<T[K]>['value'];\n};\n\n/**\n * Helper function to define a JSON schema {@link Property}.\n * @private\n * @internal\n */\nexport function property<T extends JsonTypeDesc>(\n  typeString: T,\n  optionalValue?: TSType<T>\n): Property<T> {\n  const result: Property<T> = {\n    typeString\n  };\n  if (optionalValue) {\n    result.value = optionalValue;\n  }\n  return result;\n}\n\n/**\n * Validates the JSON object based on the provided schema, and narrows the type to the provided\n * JSON schema.\n * @private\n * @internal\n *\n * @param json - A JSON object to validate.\n * @param scheme - a {@link JsonSchema} that defines the properties to validate.\n * @returns true if the JSON schema exists within the object. Throws a FirestoreError otherwise.\n */\nexport function validateJSON<S extends JsonSchema>(\n  json: object,\n  schema: S\n): json is Json<S> {\n  if (!isPlainObject(json)) {\n    throw new FirestoreError(Code.INVALID_ARGUMENT, 'JSON must be an object');\n  }\n  let error: string | undefined = undefined;\n  for (const key in schema) {\n    if (schema[key]) {\n      const typeString = schema[key].typeString;\n      const value: { value: unknown } | undefined =\n        'value' in schema[key] ? { value: schema[key].value } : undefined;\n      if (!(key in json)) {\n        error = `JSON missing required field: '${key}'`;\n        break;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const fieldValue = (json as any)[key];\n      if (typeString && typeof fieldValue !== typeString) {\n        error = `JSON field '${key}' must be a ${typeString}.`;\n        break;\n      } else if (value !== undefined && fieldValue !== value.value) {\n        error = `Expected '${key}' field to equal '${value.value}'`;\n        break;\n      }\n    }\n  }\n  if (error) {\n    throw new FirestoreError(Code.INVALID_ARGUMENT, error);\n  }\n  return true;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from '../util/error';\n// API extractor fails importing 'property' unless we also explicitly import 'Property'.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, unused-imports/no-unused-imports-ts\nimport { Property, property, validateJSON } from '../util/json_validation';\nimport { primitiveComparator } from '../util/misc';\n\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n\n// Number of nanoseconds in a millisecond.\nconst MS_TO_NANOS = 1e6;\n\n/**\n * A `Timestamp` represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time.\n *\n * It is encoded using the Proleptic Gregorian Calendar which extends the\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\n * 9999-12-31T23:59:59.999999999Z.\n *\n * For examples and further specifications, refer to the\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\n */\nexport class Timestamp {\n  /**\n   * Creates a new timestamp with the current date, with millisecond precision.\n   *\n   * @returns a new timestamp representing the current date.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromMillis(Date.now());\n  }\n\n  /**\n   * Creates a new timestamp from the given date.\n   *\n   * @param date - The date to initialize the `Timestamp` from.\n   * @returns A new `Timestamp` representing the same point in time as the given\n   *     date.\n   */\n  static fromDate(date: Date): Timestamp {\n    return Timestamp.fromMillis(date.getTime());\n  }\n\n  /**\n   * Creates a new timestamp from the given number of milliseconds.\n   *\n   * @param milliseconds - Number of milliseconds since Unix epoch\n   *     1970-01-01T00:00:00Z.\n   * @returns A new `Timestamp` representing the same point in time as the given\n   *     number of milliseconds.\n   */\n  static fromMillis(milliseconds: number): Timestamp {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n    return new Timestamp(seconds, nanos);\n  }\n\n  /**\n   * Creates a new timestamp.\n   *\n   * @param seconds - The number of seconds of UTC time since Unix epoch\n   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   *     9999-12-31T23:59:59Z inclusive.\n   * @param nanoseconds - The non-negative fractions of a second at nanosecond\n   *     resolution. Negative second values with fractions must still have\n   *     non-negative nanoseconds values that count forward in time. Must be\n   *     from 0 to 999,999,999 inclusive.\n   */\n  constructor(\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    readonly seconds: number,\n    /**\n     * The fractions of a second at nanosecond resolution.*\n     */\n    readonly nanoseconds: number\n  ) {\n    if (nanoseconds < 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp nanoseconds out of range: ' + nanoseconds\n      );\n    }\n    if (nanoseconds >= 1e9) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp nanoseconds out of range: ' + nanoseconds\n      );\n    }\n    if (seconds < MIN_SECONDS) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp seconds out of range: ' + seconds\n      );\n    }\n    // This will break in the year 10,000.\n    if (seconds >= 253402300800) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp seconds out of range: ' + seconds\n      );\n    }\n  }\n\n  /**\n   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\n   * causes a loss of precision since `Date` objects only support millisecond\n   * precision.\n   *\n   * @returns JavaScript `Date` object representing the same point in time as\n   *     this `Timestamp`, with millisecond precision.\n   */\n  toDate(): Date {\n    return new Date(this.toMillis());\n  }\n\n  /**\n   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\n   * epoch). This operation causes a loss of precision.\n   *\n   * @returns The point in time corresponding to this timestamp, represented as\n   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n   */\n  toMillis(): number {\n    return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\n  }\n\n  _compareTo(other: Timestamp): number {\n    if (this.seconds === other.seconds) {\n      return primitiveComparator(this.nanoseconds, other.nanoseconds);\n    }\n    return primitiveComparator(this.seconds, other.seconds);\n  }\n\n  /**\n   * Returns true if this `Timestamp` is equal to the provided one.\n   *\n   * @param other - The `Timestamp` to compare against.\n   * @returns true if this `Timestamp` is equal to the provided one.\n   */\n  isEqual(other: Timestamp): boolean {\n    return (\n      other.seconds === this.seconds && other.nanoseconds === this.nanoseconds\n    );\n  }\n\n  /** Returns a textual representation of this `Timestamp`. */\n  toString(): string {\n    return (\n      'Timestamp(seconds=' +\n      this.seconds +\n      ', nanoseconds=' +\n      this.nanoseconds +\n      ')'\n    );\n  }\n\n  static _jsonSchemaVersion: string = 'firestore/timestamp/1.0';\n  static _jsonSchema = {\n    type: property('string', Timestamp._jsonSchemaVersion),\n    seconds: property('number'),\n    nanoseconds: property('number')\n  };\n\n  /**\n   * Returns a JSON-serializable representation of this `Timestamp`.\n   */\n  toJSON(): { seconds: number; nanoseconds: number; type: string } {\n    return {\n      type: Timestamp._jsonSchemaVersion,\n      seconds: this.seconds,\n      nanoseconds: this.nanoseconds\n    };\n  }\n\n  /**\n   * Builds a `Timestamp` instance from a JSON object created by {@link Timestamp.toJSON}.\n   */\n  static fromJSON(json: object): Timestamp {\n    if (validateJSON(json, Timestamp._jsonSchema)) {\n      return new Timestamp(json.seconds, json.nanoseconds);\n    }\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Unexpected error creating Timestamp from JSON.'\n    );\n  }\n\n  /**\n   * Converts this object to a primitive string, which allows `Timestamp` objects\n   * to be compared using the `>`, `<=`, `>=` and `>` operators.\n   */\n  valueOf(): string {\n    // This method returns a string of the form <seconds>.<nanoseconds> where\n    // <seconds> is translated to have a non-negative value and both <seconds>\n    // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n    // Strings with this format then have a lexicographical ordering that matches\n    // the expected ordering. The <seconds> translation is done to avoid having\n    // a leading negative sign (i.e. a leading '-' character) in its string\n    // representation, which would affect its lexicographical ordering.\n    const adjustedSeconds = this.seconds - MIN_SECONDS;\n    // Note: Up to 12 decimal digits are required to represent all valid\n    // 'seconds' values.\n    const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n    const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n    return formattedSeconds + '.' + formattedNanoseconds;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../lite-api/timestamp';\n\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nexport class SnapshotVersion {\n  static fromTimestamp(value: Timestamp): SnapshotVersion {\n    return new SnapshotVersion(value);\n  }\n\n  static min(): SnapshotVersion {\n    return new SnapshotVersion(new Timestamp(0, 0));\n  }\n\n  static max(): SnapshotVersion {\n    return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\n  }\n\n  private constructor(private timestamp: Timestamp) {}\n\n  compareTo(other: SnapshotVersion): number {\n    return this.timestamp._compareTo(other.timestamp);\n  }\n\n  isEqual(other: SnapshotVersion): boolean {\n    return this.timestamp.isEqual(other.timestamp);\n  }\n\n  /** Returns a number representation of the version for use in spec tests. */\n  toMicroseconds(): number {\n    // Convert to microseconds.\n    return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n  }\n\n  toString(): string {\n    return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n  }\n\n  toTimestamp(): Timestamp {\n    return this.timestamp;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../lite-api/timestamp';\nimport { primitiveComparator } from '../util/misc';\n\nimport { Document } from './document';\nimport { DocumentKey } from './document_key';\nimport { FieldPath } from './path';\n\n/**\n * The initial mutation batch id for each index. Gets updated during index\n * backfill.\n */\nexport const INITIAL_LARGEST_BATCH_ID = -1;\n\n/**\n * The initial sequence number for each index. Gets updated during index\n * backfill.\n */\nexport const INITIAL_SEQUENCE_NUMBER = 0;\n\n/**\n * An index definition for field indexes in Firestore.\n *\n * Every index is associated with a collection. The definition contains a list\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\n *\n * Unlike the backend, the SDK does not differentiate between collection or\n * collection group-scoped indices. Every index can be used for both single\n * collection and collection group queries.\n */\nexport class FieldIndex {\n  /** An ID for an index that has not yet been added to persistence.  */\n  static UNKNOWN_ID = -1;\n\n  constructor(\n    /**\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\n     * has not yet been persisted).\n     */\n    readonly indexId: number,\n    /** The collection ID this index applies to. */\n    readonly collectionGroup: string,\n    /** The field segments for this index. */\n    readonly fields: IndexSegment[],\n    /** Shows how up-to-date the index is for the current user. */\n    readonly indexState: IndexState\n  ) {}\n}\n\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\nexport function fieldIndexGetArraySegment(\n  fieldIndex: FieldIndex\n): IndexSegment | undefined {\n  return fieldIndex.fields.find(s => s.kind === IndexKind.CONTAINS);\n}\n\n/** Returns all directional (ascending/descending) segments for this index. */\nexport function fieldIndexGetDirectionalSegments(\n  fieldIndex: FieldIndex\n): IndexSegment[] {\n  return fieldIndex.fields.filter(s => s.kind !== IndexKind.CONTAINS);\n}\n\n/**\n * Returns the order of the document key component for the given index.\n *\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\n */\nexport function fieldIndexGetKeyOrder(fieldIndex: FieldIndex): IndexKind {\n  const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\n  return directionalSegments.length === 0\n    ? IndexKind.ASCENDING\n    : directionalSegments[directionalSegments.length - 1].kind;\n}\n\n/**\n * Compares indexes by collection group and segments. Ignores update time and\n * index ID.\n */\nexport function fieldIndexSemanticComparator(\n  left: FieldIndex,\n  right: FieldIndex\n): number {\n  let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\n    cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\n    if (cmp !== 0) {\n      return cmp;\n    }\n  }\n  return primitiveComparator(left.fields.length, right.fields.length);\n}\n\n/** Returns a debug representation of the field index */\nexport function fieldIndexToString(fieldIndex: FieldIndex): string {\n  return `id=${fieldIndex.indexId}|cg=${\n    fieldIndex.collectionGroup\n  }|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\n}\n\n/** The type of the index, e.g. for which type of query it can be used. */\nexport const enum IndexKind {\n  // Note: The order of these values cannot be changed as the enum values are\n  // stored in IndexedDb.\n  /**\n   * Ordered index. Can be used for <, <=, ==, >=, >, !=, IN and NOT IN queries.\n   */\n  ASCENDING,\n  /**\n   * Ordered index. Can be used for <, <=, ==, >=, >, !=, IN and NOT IN queries.\n   */\n  DESCENDING,\n  /** Contains index. Can be used for ArrayContains and ArrayContainsAny. */\n  CONTAINS\n}\n\n/** An index component consisting of field path and index type.  */\nexport class IndexSegment {\n  constructor(\n    /** The field path of the component. */\n    readonly fieldPath: FieldPath,\n    /** The fields sorting order. */\n    readonly kind: IndexKind\n  ) {}\n}\n\nfunction indexSegmentComparator(\n  left: IndexSegment,\n  right: IndexSegment\n): number {\n  const cmp = FieldPath.comparator(left.fieldPath, right.fieldPath);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return primitiveComparator(left.kind, right.kind);\n}\n\n/**\n * Stores the \"high water mark\" that indicates how updated the Index is for the\n * current user.\n */\nexport class IndexState {\n  constructor(\n    /**\n     * Indicates when the index was last updated (relative to other indexes).\n     */\n    readonly sequenceNumber: number,\n    /** The the latest indexed read time, document and batch id. */\n    readonly offset: IndexOffset\n  ) {}\n\n  /** The state of an index that has not yet been backfilled. */\n  static empty(): IndexState {\n    return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\n  }\n}\n\n/**\n * Creates an offset that matches all documents with a read time higher than\n * `readTime`.\n */\nexport function newIndexOffsetSuccessorFromReadTime(\n  readTime: SnapshotVersion,\n  largestBatchId: number\n): IndexOffset {\n  // We want to create an offset that matches all documents with a read time\n  // greater than the provided read time. To do so, we technically need to\n  // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\n  // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\n  // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\n  // all valid document IDs.\n  const successorSeconds = readTime.toTimestamp().seconds;\n  const successorNanos = readTime.toTimestamp().nanoseconds + 1;\n  const successor = SnapshotVersion.fromTimestamp(\n    successorNanos === 1e9\n      ? new Timestamp(successorSeconds + 1, 0)\n      : new Timestamp(successorSeconds, successorNanos)\n  );\n  return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\n}\n\n/** Creates a new offset based on the provided document. */\nexport function newIndexOffsetFromDocument(document: Document): IndexOffset {\n  return new IndexOffset(\n    document.readTime,\n    document.key,\n    INITIAL_LARGEST_BATCH_ID\n  );\n}\n\n/**\n * Stores the latest read time, document and batch ID that were processed for an\n * index.\n */\nexport class IndexOffset {\n  constructor(\n    /**\n     * The latest read time version that has been indexed by Firestore for this\n     * field index.\n     */\n    readonly readTime: SnapshotVersion,\n\n    /**\n     * The key of the last document that was indexed for this query. Use\n     * `DocumentKey.empty()` if no document has been indexed.\n     */\n    readonly documentKey: DocumentKey,\n\n    /*\n     * The largest mutation batch id that's been processed by Firestore.\n     */\n    readonly largestBatchId: number\n  ) {}\n\n  /** Returns an offset that sorts before all regular offsets. */\n  static min(): IndexOffset {\n    return new IndexOffset(\n      SnapshotVersion.min(),\n      DocumentKey.empty(),\n      INITIAL_LARGEST_BATCH_ID\n    );\n  }\n\n  /** Returns an offset that sorts after all regular offsets. */\n  static max(): IndexOffset {\n    return new IndexOffset(\n      SnapshotVersion.max(),\n      DocumentKey.empty(),\n      INITIAL_LARGEST_BATCH_ID\n    );\n  }\n}\n\nexport function indexOffsetComparator(\n  left: IndexOffset,\n  right: IndexOffset\n): number {\n  let cmp = left.readTime.compareTo(right.readTime);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return primitiveComparator(left.largestBatchId, right.largestBatchId);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ListenSequenceNumber } from '../core/types';\nexport const PRIMARY_LEASE_LOST_ERROR_MSG =\n  'The current tab is not in the required state to perform this operation. ' +\n  'It might be necessary to refresh the browser tab.';\n\n/** The different modes supported by `Persistence.runTransaction()`. */\nexport type PersistenceTransactionMode =\n  | 'readonly'\n  | 'readwrite'\n  | 'readwrite-primary';\n\n/**\n * A base class representing a persistence transaction, encapsulating both the\n * transaction's sequence numbers as well as a list of onCommitted listeners.\n *\n * When you call Persistence.runTransaction(), it will create a transaction and\n * pass it to your callback. You then pass it to any method that operates\n * on persistence.\n */\nexport abstract class PersistenceTransaction {\n  private readonly onCommittedListeners: Array<() => void> = [];\n\n  abstract readonly currentSequenceNumber: ListenSequenceNumber;\n\n  addOnCommittedListener(listener: () => void): void {\n    this.onCommittedListeners.push(listener);\n  }\n\n  raiseOnCommittedEvent(): void {\n    this.onCommittedListeners.forEach(listener => listener());\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\n\nimport { IndexManager } from './index_manager';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { LruGarbageCollector, LruResults } from './lru_garbage_collector';\nimport { PRIMARY_LEASE_LOST_ERROR_MSG } from './persistence_transaction';\n\nexport interface LocalStore {\n  collectGarbage(garbageCollector: LruGarbageCollector): Promise<LruResults>;\n\n  /** Manages the list of active field and collection indices. */\n  indexManager: IndexManager;\n\n  /**\n   * The \"local\" view of all documents (layering mutationQueue on top of\n   * remoteDocumentCache).\n   */\n  localDocuments: LocalDocumentsView;\n}\n\n/**\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\n * operation fails because the primary lease has been taken by another client,\n * we ignore the error (the persistence layer will immediately call\n * `applyPrimaryLease` to propagate the primary state change). All other errors\n * are re-thrown.\n *\n * @param err - An error returned by a LocalStore operation.\n * @returns A Promise that resolves after we recovered, or the original error.\n */\nexport async function ignoreIfPrimaryLeaseLoss(\n  err: FirestoreError\n): Promise<void> {\n  if (\n    err.code === Code.FAILED_PRECONDITION &&\n    err.message === PRIMARY_LEASE_LOST_ERROR_MSG\n  ) {\n    logDebug('LocalStore', 'Unexpectedly lost primary lease');\n  } else {\n    throw err;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fail } from '../util/assert';\n\nexport type FulfilledHandler<T, R> =\n  | ((result: T) => R | PersistencePromise<R>)\n  | null;\nexport type RejectedHandler<R> =\n  | ((reason: Error) => R | PersistencePromise<R>)\n  | null;\nexport type Resolver<T> = (value?: T) => void;\nexport type Rejector = (error: Error) => void;\n\n/**\n * PersistencePromise is essentially a re-implementation of Promise except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nexport class PersistencePromise<T> {\n  // NOTE: next/catchCallback will always point to our own wrapper functions,\n  // not the user's raw next() or catch() callbacks.\n  private nextCallback: FulfilledHandler<T, unknown> = null;\n  private catchCallback: RejectedHandler<unknown> = null;\n\n  // When the operation resolves, we'll set result or error and mark isDone.\n  private result: T | undefined = undefined;\n  private error: Error | undefined = undefined;\n  private isDone = false;\n\n  // Set to true when .then() or .catch() are called and prevents additional\n  // chaining.\n  private callbackAttached = false;\n\n  constructor(callback: (resolve: Resolver<T>, reject: Rejector) => void) {\n    callback(\n      value => {\n        this.isDone = true;\n        this.result = value;\n        if (this.nextCallback) {\n          // value should be defined unless T is Void, but we can't express\n          // that in the type system.\n          this.nextCallback(value!);\n        }\n      },\n      error => {\n        this.isDone = true;\n        this.error = error;\n        if (this.catchCallback) {\n          this.catchCallback(error);\n        }\n      }\n    );\n  }\n\n  catch<R>(\n    fn: (error: Error) => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    return this.next(undefined, fn);\n  }\n\n  next<R>(\n    nextFn?: FulfilledHandler<T, R>,\n    catchFn?: RejectedHandler<R>\n  ): PersistencePromise<R> {\n    if (this.callbackAttached) {\n      fail(0xe830, 'Called next() or catch() twice for PersistencePromise');\n    }\n    this.callbackAttached = true;\n    if (this.isDone) {\n      if (!this.error) {\n        return this.wrapSuccess(nextFn, this.result!);\n      } else {\n        return this.wrapFailure(catchFn, this.error);\n      }\n    } else {\n      return new PersistencePromise<R>((resolve, reject) => {\n        this.nextCallback = (value: T) => {\n          this.wrapSuccess(nextFn, value).next(resolve, reject);\n        };\n        this.catchCallback = (error: Error) => {\n          this.wrapFailure(catchFn, error).next(resolve, reject);\n        };\n      });\n    }\n  }\n\n  toPromise(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.next(resolve, reject);\n    });\n  }\n\n  private wrapUserFunction<R>(\n    fn: () => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    try {\n      const result = fn();\n      if (result instanceof PersistencePromise) {\n        return result;\n      } else {\n        return PersistencePromise.resolve(result);\n      }\n    } catch (e) {\n      return PersistencePromise.reject<R>(e as Error);\n    }\n  }\n\n  private wrapSuccess<R>(\n    nextFn: FulfilledHandler<T, R> | undefined,\n    value: T\n  ): PersistencePromise<R> {\n    if (nextFn) {\n      return this.wrapUserFunction(() => nextFn(value));\n    } else {\n      // If there's no nextFn, then R must be the same as T\n      return PersistencePromise.resolve<R>(value as unknown as R);\n    }\n  }\n\n  private wrapFailure<R>(\n    catchFn: RejectedHandler<R> | undefined,\n    error: Error\n  ): PersistencePromise<R> {\n    if (catchFn) {\n      return this.wrapUserFunction(() => catchFn(error));\n    } else {\n      return PersistencePromise.reject<R>(error);\n    }\n  }\n\n  static resolve(): PersistencePromise<void>;\n  static resolve<R>(result: R): PersistencePromise<R>;\n  static resolve<R>(result?: R): PersistencePromise<R | void> {\n    return new PersistencePromise<R | void>((resolve, reject) => {\n      resolve(result);\n    });\n  }\n\n  static reject<R>(error: Error): PersistencePromise<R> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  static waitFor(\n    // Accept all Promise types in waitFor().\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    all: { forEach: (cb: (el: PersistencePromise<any>) => void) => void }\n  ): PersistencePromise<void> {\n    return new PersistencePromise<void>((resolve, reject) => {\n      let expectedCount = 0;\n      let resolvedCount = 0;\n      let done = false;\n\n      all.forEach(element => {\n        ++expectedCount;\n        element.next(\n          () => {\n            ++resolvedCount;\n            if (done && resolvedCount === expectedCount) {\n              resolve();\n            }\n          },\n          err => reject(err)\n        );\n      });\n\n      done = true;\n      if (resolvedCount === expectedCount) {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Given an array of predicate functions that asynchronously evaluate to a\n   * boolean, implements a short-circuiting `or` between the results. Predicates\n   * will be evaluated until one of them returns `true`, then stop. The final\n   * result will be whether any of them returned `true`.\n   */\n  static or(\n    predicates: Array<() => PersistencePromise<boolean>>\n  ): PersistencePromise<boolean> {\n    let p: PersistencePromise<boolean> =\n      PersistencePromise.resolve<boolean>(false);\n    for (const predicate of predicates) {\n      p = p.next(isTrue => {\n        if (isTrue) {\n          return PersistencePromise.resolve<boolean>(isTrue);\n        } else {\n          return predicate();\n        }\n      });\n    }\n    return p;\n  }\n\n  /**\n   * Given an iterable, call the given function on each element in the\n   * collection and wait for all of the resulting concurrent PersistencePromises\n   * to resolve.\n   */\n  static forEach<R, S>(\n    collection: { forEach: (cb: (r: R, s: S) => void) => void },\n    f:\n      | ((r: R, s: S) => PersistencePromise<void>)\n      | ((r: R) => PersistencePromise<void>)\n  ): PersistencePromise<void>;\n  static forEach<R>(\n    collection: { forEach: (cb: (r: R) => void) => void },\n    f: (r: R) => PersistencePromise<void>\n  ): PersistencePromise<void>;\n  static forEach<R, S>(\n    collection: { forEach: (cb: (r: R, s?: S) => void) => void },\n    f: (r: R, s?: S) => PersistencePromise<void>\n  ): PersistencePromise<void> {\n    const promises: Array<PersistencePromise<void>> = [];\n    collection.forEach((r, s) => {\n      promises.push(f.call(this, r, s));\n    });\n    return this.waitFor(promises);\n  }\n\n  /**\n   * Concurrently map all array elements through asynchronous function.\n   */\n  static mapArray<T, U>(\n    array: T[],\n    f: (t: T) => PersistencePromise<U>\n  ): PersistencePromise<U[]> {\n    return new PersistencePromise<U[]>((resolve, reject) => {\n      const expectedCount = array.length;\n      const results: U[] = new Array(expectedCount);\n      let resolvedCount = 0;\n      for (let i = 0; i < expectedCount; i++) {\n        const current = i;\n        f(array[current]).next(\n          result => {\n            results[current] = result;\n            ++resolvedCount;\n            if (resolvedCount === expectedCount) {\n              resolve(results);\n            }\n          },\n          err => reject(err)\n        );\n      }\n    });\n  }\n\n  /**\n   * An alternative to recursive PersistencePromise calls, that avoids\n   * potential memory problems from unbounded chains of promises.\n   *\n   * The `action` will be called repeatedly while `condition` is true.\n   */\n  static doWhile(\n    condition: () => boolean,\n    action: () => PersistencePromise<void>\n  ): PersistencePromise<void> {\n    return new PersistencePromise<void>((resolve, reject) => {\n      const process = (): void => {\n        if (condition() === true) {\n          action().next(() => {\n            process();\n          }, reject);\n        } else {\n          resolve();\n        }\n      };\n      process();\n    });\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal, getUA, isIndexedDBAvailable } from '@firebase/util';\n\nimport { debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug, logError } from '../util/log';\nimport { Deferred } from '../util/promise';\n\nimport { PersistencePromise } from './persistence_promise';\n\n// References to `indexedDB` are guarded by SimpleDb.isAvailable() and getGlobal()\n/* eslint-disable no-restricted-globals */\n\nconst LOG_TAG = 'SimpleDb';\n\n/**\n * The maximum number of retry attempts for an IndexedDb transaction that fails\n * with a DOMException.\n */\nconst TRANSACTION_RETRY_COUNT = 3;\n\n// The different modes supported by `SimpleDb.runTransaction()`\ntype SimpleDbTransactionMode = 'readonly' | 'readwrite';\n\nexport interface SimpleDbSchemaConverter {\n  createOrUpgrade(\n    db: IDBDatabase,\n    txn: IDBTransaction,\n    fromVersion: number,\n    toVersion: number\n  ): PersistencePromise<void>;\n}\n\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nexport class SimpleDbTransaction {\n  private aborted = false;\n\n  /**\n   * A `Promise` that resolves with the result of the IndexedDb transaction.\n   */\n  private readonly completionDeferred = new Deferred<void>();\n\n  static open(\n    db: IDBDatabase,\n    action: string,\n    mode: IDBTransactionMode,\n    objectStoreNames: string[]\n  ): SimpleDbTransaction {\n    try {\n      return new SimpleDbTransaction(\n        action,\n        db.transaction(objectStoreNames, mode)\n      );\n    } catch (e) {\n      throw new IndexedDbTransactionError(action, e as Error);\n    }\n  }\n\n  constructor(\n    private readonly action: string,\n    private readonly transaction: IDBTransaction\n  ) {\n    this.transaction.oncomplete = () => {\n      this.completionDeferred.resolve();\n    };\n    this.transaction.onabort = () => {\n      if (transaction.error) {\n        this.completionDeferred.reject(\n          new IndexedDbTransactionError(action, transaction.error)\n        );\n      } else {\n        this.completionDeferred.resolve();\n      }\n    };\n    this.transaction.onerror = (event: Event) => {\n      const error = checkForAndReportiOSError(\n        (event.target as IDBRequest).error!\n      );\n      this.completionDeferred.reject(\n        new IndexedDbTransactionError(action, error)\n      );\n    };\n  }\n\n  get completionPromise(): Promise<void> {\n    return this.completionDeferred.promise;\n  }\n\n  abort(error?: Error): void {\n    if (error) {\n      this.completionDeferred.reject(error);\n    }\n\n    if (!this.aborted) {\n      logDebug(\n        LOG_TAG,\n        'Aborting transaction:',\n        error ? error.message : 'Client-initiated abort'\n      );\n      this.aborted = true;\n      this.transaction.abort();\n    }\n  }\n\n  maybeCommit(): void {\n    // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\n    // speed up index DB processing if the event loop remains blocks.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const maybeV3IndexedDb = this.transaction as any;\n    if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\n      maybeV3IndexedDb.commit();\n    }\n  }\n\n  /**\n   * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n   * operations performed on the SimpleDbStore happen within the context of this\n   * transaction and it cannot be used anymore once the transaction is\n   * completed.\n   *\n   * Note that we can't actually enforce that the KeyType and ValueType are\n   * correct, but they allow type safety through the rest of the consuming code.\n   */\n  store<KeyType extends IDBValidKey, ValueType extends unknown>(\n    storeName: string\n  ): SimpleDbStore<KeyType, ValueType> {\n    const store = this.transaction.objectStore(storeName);\n    debugAssert(!!store, 'Object store not part of transaction: ' + storeName);\n    return new SimpleDbStore<KeyType, ValueType>(store);\n  }\n}\n\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nexport class SimpleDb {\n  private db?: IDBDatabase;\n  private lastClosedDbVersion: number | null = null;\n  private versionchangelistener?: (event: IDBVersionChangeEvent) => void;\n\n  /** Deletes the specified database. */\n  static delete(name: string): Promise<void> {\n    logDebug(LOG_TAG, 'Removing database:', name);\n    const globals = getGlobal();\n    return wrapRequest<void>(\n      globals.indexedDB.deleteDatabase(name)\n    ).toPromise();\n  }\n\n  /** Returns true if IndexedDB is available in the current environment. */\n  static isAvailable(): boolean {\n    if (!isIndexedDBAvailable()) {\n      return false;\n    }\n\n    if (SimpleDb.isMockPersistence()) {\n      return true;\n    }\n\n    // We extensively use indexed array values and compound keys,\n    // which IE and Edge do not support. However, they still have indexedDB\n    // defined on the window, so we need to check for them here and make sure\n    // to return that persistence is not enabled for those browsers.\n    // For tracking support of this feature, see here:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n\n    // Check the UA string to find out the browser.\n    const ua = getUA();\n\n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n\n    // Edge\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n    // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n\n    // iOS Safari: Disable for users running iOS version < 10.\n    const iOSVersion = SimpleDb.getIOSVersion(ua);\n    const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\n\n    // Android browser: Disable for users running version < 4.5.\n    const androidVersion = getAndroidVersion(ua);\n    const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\n\n    if (\n      ua.indexOf('MSIE ') > 0 ||\n      ua.indexOf('Trident/') > 0 ||\n      ua.indexOf('Edge/') > 0 ||\n      isUnsupportedIOS ||\n      isUnsupportedAndroid\n    ) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Returns true if the backing IndexedDB store is the Node IndexedDBShim\n   * (see https://github.com/axemclion/IndexedDBShim).\n   */\n  static isMockPersistence(): boolean {\n    return (\n      typeof process !== 'undefined' &&\n      process.env?.USE_MOCK_PERSISTENCE === 'YES'\n    );\n  }\n\n  /** Helper to get a typed SimpleDbStore from a transaction. */\n  static getStore<KeyType extends IDBValidKey, ValueType extends unknown>(\n    txn: SimpleDbTransaction,\n    store: string\n  ): SimpleDbStore<KeyType, ValueType> {\n    return txn.store<KeyType, ValueType>(store);\n  }\n\n  // visible for testing\n  /** Parse User Agent to determine iOS version. Returns -1 if not found. */\n  static getIOSVersion(ua: string): number {\n    const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\n    const version = iOSVersionRegex\n      ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\n      : '-1';\n    return Number(version);\n  }\n\n  /*\n   * Creates a new SimpleDb wrapper for IndexedDb database `name`.\n   *\n   * Note that `version` must not be a downgrade. IndexedDB does not support\n   * downgrading the schema version. We currently do not support any way to do\n   * versioning outside of IndexedDB's versioning mechanism, as only\n   * version-upgrade transactions are allowed to do things like create\n   * objectstores.\n   */\n  constructor(\n    private readonly name: string,\n    private readonly version: number,\n    private readonly schemaConverter: SimpleDbSchemaConverter\n  ) {\n    debugAssert(\n      SimpleDb.isAvailable(),\n      'IndexedDB not supported in current environment.'\n    );\n\n    const iOSVersion = SimpleDb.getIOSVersion(getUA());\n    // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\n    // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\n    // whatever reason it's much harder to hit after 12.2 so we only proactively\n    // log on 12.2.\n    if (iOSVersion === 12.2) {\n      logError(\n        'Firestore persistence suffers from a bug in iOS 12.2 ' +\n          'Safari that may cause your app to stop working. See ' +\n          'https://stackoverflow.com/q/56496296/110915 for details ' +\n          'and a potential workaround.'\n      );\n    }\n  }\n\n  /**\n   * Opens the specified database, creating or upgrading it if necessary.\n   */\n  async ensureDb(action: string): Promise<IDBDatabase> {\n    if (!this.db) {\n      logDebug(LOG_TAG, 'Opening database:', this.name);\n      this.db = await new Promise<IDBDatabase>((resolve, reject) => {\n        // TODO(mikelehen): Investigate browser compatibility.\n        // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n        // suggests IE9 and older WebKit browsers handle upgrade\n        // differently. They expect setVersion, as described here:\n        // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n        const request = indexedDB.open(this.name, this.version);\n\n        request.onsuccess = (event: Event) => {\n          const db = (event.target as IDBOpenDBRequest).result;\n          resolve(db);\n        };\n\n        request.onblocked = () => {\n          reject(\n            new IndexedDbTransactionError(\n              action,\n              'Cannot upgrade IndexedDB schema while another tab is open. ' +\n                'Close all tabs that access Firestore and reload this page to proceed.'\n            )\n          );\n        };\n\n        request.onerror = (event: Event) => {\n          const error: DOMException = (event.target as IDBOpenDBRequest).error!;\n          if (error.name === 'VersionError') {\n            reject(\n              new FirestoreError(\n                Code.FAILED_PRECONDITION,\n                'A newer version of the Firestore SDK was previously used and so the persisted ' +\n                  'data is not compatible with the version of the SDK you are now using. The SDK ' +\n                  'will operate with persistence disabled. If you need persistence, please ' +\n                  're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\n                  'data for your app to start fresh.'\n              )\n            );\n          } else if (error.name === 'InvalidStateError') {\n            reject(\n              new FirestoreError(\n                Code.FAILED_PRECONDITION,\n                'Unable to open an IndexedDB connection. This could be due to running in a ' +\n                  'private browsing session on a browser whose private browsing sessions do not ' +\n                  'support IndexedDB: ' +\n                  error\n              )\n            );\n          } else {\n            reject(new IndexedDbTransactionError(action, error));\n          }\n        };\n\n        request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n          logDebug(\n            LOG_TAG,\n            'Database \"' + this.name + '\" requires upgrade from version:',\n            event.oldVersion\n          );\n          const db = (event.target as IDBOpenDBRequest).result;\n          this.schemaConverter\n            .createOrUpgrade(\n              db,\n              request.transaction!,\n              event.oldVersion,\n              this.version\n            )\n            .next(() => {\n              logDebug(\n                LOG_TAG,\n                'Database upgrade to version ' + this.version + ' complete'\n              );\n            });\n        };\n      });\n    }\n\n    if (this.versionchangelistener) {\n      this.db.onversionchange = event => this.versionchangelistener!(event);\n    }\n\n    return this.db;\n  }\n\n  setVersionChangeListener(\n    versionChangeListener: (event: IDBVersionChangeEvent) => void\n  ): void {\n    this.versionchangelistener = versionChangeListener;\n    if (this.db) {\n      this.db.onversionchange = (event: IDBVersionChangeEvent) => {\n        return versionChangeListener(event);\n      };\n    }\n  }\n\n  async runTransaction<T>(\n    action: string,\n    mode: SimpleDbTransactionMode,\n    objectStores: string[],\n    transactionFn: (transaction: SimpleDbTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    const readonly = mode === 'readonly';\n    let attemptNumber = 0;\n\n    while (true) {\n      ++attemptNumber;\n\n      try {\n        this.db = await this.ensureDb(action);\n\n        const transaction = SimpleDbTransaction.open(\n          this.db,\n          action,\n          readonly ? 'readonly' : 'readwrite',\n          objectStores\n        );\n        const transactionFnResult = transactionFn(transaction)\n          .next(result => {\n            transaction.maybeCommit();\n            return result;\n          })\n          .catch(error => {\n            // Abort the transaction if there was an error.\n            transaction.abort(error);\n            // We cannot actually recover, and calling `abort()` will cause the transaction's\n            // completion promise to be rejected. This in turn means that we won't use\n            // `transactionFnResult` below. We return a rejection here so that we don't add the\n            // possibility of returning `void` to the type of `transactionFnResult`.\n            return PersistencePromise.reject<T>(error);\n          })\n          .toPromise();\n\n        // As noted above, errors are propagated by aborting the transaction. So\n        // we swallow any error here to avoid the browser logging it as unhandled.\n        transactionFnResult.catch(() => {});\n\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        await transaction.completionPromise;\n        return transactionFnResult;\n      } catch (e) {\n        const error = e as Error;\n        // TODO(schmidt-sebastian): We could probably be smarter about this and\n        // not retry exceptions that are likely unrecoverable (such as quota\n        // exceeded errors).\n\n        // Note: We cannot use an instanceof check for FirestoreException, since the\n        // exception is wrapped in a generic error by our async/await handling.\n        const retryable =\n          error.name !== 'FirebaseError' &&\n          attemptNumber < TRANSACTION_RETRY_COUNT;\n        logDebug(\n          LOG_TAG,\n          'Transaction failed with error:',\n          error.message,\n          'Retrying:',\n          retryable\n        );\n\n        this.close();\n\n        if (!retryable) {\n          return Promise.reject(error);\n        }\n      }\n    }\n  }\n\n  close(): void {\n    if (this.db) {\n      this.db.close();\n    }\n    this.db = undefined;\n  }\n}\n\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\nexport function getAndroidVersion(ua: string): number {\n  const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\n  const version = androidVersionRegex\n    ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\n    : '-1';\n  return Number(version);\n}\n\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nexport class IterationController {\n  private shouldStop = false;\n  private nextKey: IDBValidKey | null = null;\n\n  constructor(private dbCursor: IDBCursorWithValue) {}\n\n  get isDone(): boolean {\n    return this.shouldStop;\n  }\n\n  get skipToKey(): IDBValidKey | null {\n    return this.nextKey;\n  }\n\n  set cursor(value: IDBCursorWithValue) {\n    this.dbCursor = value;\n  }\n\n  /**\n   * This function can be called to stop iteration at any point.\n   */\n  done(): void {\n    this.shouldStop = true;\n  }\n\n  /**\n   * This function can be called to skip to that next key, which could be\n   * an index or a primary key.\n   */\n  skip(key: IDBValidKey): void {\n    this.nextKey = key;\n  }\n\n  /**\n   * Delete the current cursor value from the object store.\n   *\n   * NOTE: You CANNOT do this with a keysOnly query.\n   */\n  delete(): PersistencePromise<void> {\n    return wrapRequest<void>(this.dbCursor.delete());\n  }\n}\n\n/**\n * Callback used with iterate() method.\n */\nexport type IterateCallback<KeyType, ValueType> = (\n  key: KeyType,\n  value: ValueType,\n  control: IterationController\n) => void | PersistencePromise<void>;\n\n/** Options available to the iterate() method. */\nexport interface IterateOptions {\n  /** Index to iterate over (else primary keys will be iterated) */\n  index?: string;\n\n  /** IndexedDB Range to iterate over (else entire store will be iterated) */\n  range?: IDBKeyRange;\n\n  /** If true, values aren't read while iterating. */\n  keysOnly?: boolean;\n\n  /** If true, iterate over the store in reverse. */\n  reverse?: boolean;\n}\n\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\nexport class IndexedDbTransactionError extends FirestoreError {\n  name = 'IndexedDbTransactionError';\n\n  constructor(actionName: string, cause: Error | string) {\n    super(\n      Code.UNAVAILABLE,\n      `IndexedDB transaction '${actionName}' failed: ${cause}`\n    );\n  }\n}\n\n/** Verifies whether `e` is an IndexedDbTransactionError. */\nexport function isIndexedDbTransactionError(e: Error): boolean {\n  // Use name equality, as instanceof checks on errors don't work with errors\n  // that wrap other errors.\n  return e.name === 'IndexedDbTransactionError';\n}\n\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nexport class SimpleDbStore<\n  KeyType extends IDBValidKey,\n  ValueType extends unknown\n> {\n  constructor(private store: IDBObjectStore) {}\n\n  /**\n   * Writes a value into the Object Store.\n   *\n   * @param key - Optional explicit key to use when writing the object, else the\n   * key will be auto-assigned (e.g. via the defined keyPath for the store).\n   * @param value - The object to write.\n   */\n  put(value: ValueType): PersistencePromise<void>;\n  put(key: KeyType, value: ValueType): PersistencePromise<void>;\n  put(\n    keyOrValue: KeyType | ValueType,\n    value?: ValueType\n  ): PersistencePromise<void> {\n    let request;\n    if (value !== undefined) {\n      logDebug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n      request = this.store.put(value, keyOrValue as KeyType);\n    } else {\n      logDebug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n      request = this.store.put(keyOrValue as ValueType);\n    }\n    return wrapRequest<void>(request);\n  }\n\n  /**\n   * Adds a new value into an Object Store and returns the new key. Similar to\n   * IndexedDb's `add()`, this method will fail on primary key collisions.\n   *\n   * @param value - The object to write.\n   * @returns The key of the value to add.\n   */\n  add(value: ValueType): PersistencePromise<KeyType> {\n    logDebug(LOG_TAG, 'ADD', this.store.name, value, value);\n    const request = this.store.add(value as ValueType);\n    return wrapRequest<KeyType>(request);\n  }\n\n  /**\n   * Gets the object with the specified key from the specified store, or null\n   * if no object exists with the specified key.\n   *\n   * @key The key of the object to get.\n   * @returns The object with the specified key or null if no object exists.\n   */\n  get(key: KeyType): PersistencePromise<ValueType | null> {\n    const request = this.store.get(key);\n    // We're doing an unsafe cast to ValueType.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return wrapRequest<any>(request).next(result => {\n      // Normalize nonexistence to null.\n      if (result === undefined) {\n        result = null;\n      }\n      logDebug(LOG_TAG, 'GET', this.store.name, key, result);\n      return result;\n    });\n  }\n\n  delete(key: KeyType | IDBKeyRange): PersistencePromise<void> {\n    logDebug(LOG_TAG, 'DELETE', this.store.name, key);\n    const request = this.store.delete(key);\n    return wrapRequest<void>(request);\n  }\n\n  /**\n   * If we ever need more of the count variants, we can add overloads. For now,\n   * all we need is to count everything in a store.\n   *\n   * Returns the number of rows in the store.\n   */\n  count(): PersistencePromise<number> {\n    logDebug(LOG_TAG, 'COUNT', this.store.name);\n    const request = this.store.count();\n    return wrapRequest<number>(request);\n  }\n\n  /** Loads all elements from the object store. */\n  loadAll(): PersistencePromise<ValueType[]>;\n  /** Loads all elements for the index range from the object store. */\n  loadAll(range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  /** Loads all elements ordered by the given index. */\n  loadAll(index: string): PersistencePromise<ValueType[]>;\n  /**\n   * Loads all elements from the object store that fall into the provided in the\n   * index range for the given index.\n   */\n  loadAll(index: string, range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<ValueType[]> {\n    const iterateOptions = this.options(indexOrRange, range);\n    // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\n    // 20% faster.\n    const store = iterateOptions.index\n      ? this.store.index(iterateOptions.index)\n      : this.store;\n    if (typeof store.getAll === 'function') {\n      const request = store.getAll(iterateOptions.range);\n      return new PersistencePromise((resolve, reject) => {\n        request.onerror = (event: Event) => {\n          reject((event.target as IDBRequest).error!);\n        };\n        request.onsuccess = (event: Event) => {\n          resolve((event.target as IDBRequest).result);\n        };\n      });\n    } else {\n      const cursor = this.cursor(iterateOptions);\n      const results: ValueType[] = [];\n      return this.iterateCursor(cursor, (key, value) => {\n        results.push(value);\n      }).next(() => {\n        return results;\n      });\n    }\n  }\n\n  /**\n   * Loads the first `count` elements from the provided index range. Loads all\n   * elements if no limit is provided.\n   */\n  loadFirst(\n    range: IDBKeyRange,\n    count: number | null\n  ): PersistencePromise<ValueType[]> {\n    const request = this.store.getAll(\n      range,\n      count === null ? undefined : count\n    );\n    return new PersistencePromise((resolve, reject) => {\n      request.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error!);\n      };\n      request.onsuccess = (event: Event) => {\n        resolve((event.target as IDBRequest).result);\n      };\n    });\n  }\n\n  deleteAll(): PersistencePromise<void>;\n  deleteAll(range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(index: string, range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<void> {\n    logDebug(LOG_TAG, 'DELETE ALL', this.store.name);\n    const options = this.options(indexOrRange, range);\n    options.keysOnly = false;\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, (key, value, control) => {\n      // NOTE: Calling delete() on a cursor is documented as more efficient than\n      // calling delete() on an object store with a single key\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n      // however, this requires us *not* to use a keysOnly cursor\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n      // may want to compare the performance of each method.\n      return control.delete();\n    });\n  }\n\n  /**\n   * Iterates over keys and values in an object store.\n   *\n   * @param options - Options specifying how to iterate the objects in the\n   * store.\n   * @param callback - will be called for each iterated object. Iteration can be\n   * canceled at any point by calling the doneFn passed to the callback.\n   * The callback can return a PersistencePromise if it performs async\n   * operations but note that iteration will continue without waiting for them\n   * to complete.\n   * @returns A PersistencePromise that resolves once all PersistencePromises\n   * returned by callbacks resolve.\n   */\n  iterate(\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    options: IterateOptions,\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    optionsOrCallback: IterateOptions | IterateCallback<KeyType, ValueType>,\n    callback?: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    let options;\n    if (!callback) {\n      options = {};\n      callback = optionsOrCallback as IterateCallback<KeyType, ValueType>;\n    } else {\n      options = optionsOrCallback as IterateOptions;\n    }\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, callback);\n  }\n\n  /**\n   * Iterates over a store, but waits for the given callback to complete for\n   * each entry before iterating the next entry. This allows the callback to do\n   * asynchronous work to determine if this iteration should continue.\n   *\n   * The provided callback should return `true` to continue iteration, and\n   * `false` otherwise.\n   */\n  iterateSerial(\n    callback: (k: KeyType, v: ValueType) => PersistencePromise<boolean>\n  ): PersistencePromise<void> {\n    const cursorRequest = this.cursor({});\n    return new PersistencePromise((resolve, reject) => {\n      cursorRequest.onerror = (event: Event) => {\n        const error = checkForAndReportiOSError(\n          (event.target as IDBRequest).error!\n        );\n        reject(error);\n      };\n      cursorRequest.onsuccess = (event: Event) => {\n        const cursor: IDBCursorWithValue = (event.target as IDBRequest).result;\n        if (!cursor) {\n          resolve();\n          return;\n        }\n\n        callback(cursor.primaryKey as KeyType, cursor.value).next(\n          shouldContinue => {\n            if (shouldContinue) {\n              cursor.continue();\n            } else {\n              resolve();\n            }\n          }\n        );\n      };\n    });\n  }\n\n  private iterateCursor(\n    cursorRequest: IDBRequest,\n    fn: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    const results: Array<PersistencePromise<void>> = [];\n    return new PersistencePromise((resolve, reject) => {\n      cursorRequest.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error!);\n      };\n      cursorRequest.onsuccess = (event: Event) => {\n        const cursor: IDBCursorWithValue = (event.target as IDBRequest).result;\n        if (!cursor) {\n          resolve();\n          return;\n        }\n        const controller = new IterationController(cursor);\n        const userResult = fn(\n          cursor.primaryKey as KeyType,\n          cursor.value,\n          controller\n        );\n        if (userResult instanceof PersistencePromise) {\n          const userPromise: PersistencePromise<void> = userResult.catch(\n            err => {\n              controller.done();\n              return PersistencePromise.reject(err);\n            }\n          );\n          results.push(userPromise);\n        }\n        if (controller.isDone) {\n          resolve();\n        } else if (controller.skipToKey === null) {\n          cursor.continue();\n        } else {\n          cursor.continue(controller.skipToKey);\n        }\n      };\n    }).next(() => PersistencePromise.waitFor(results));\n  }\n\n  private options(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): IterateOptions {\n    let indexName: string | undefined = undefined;\n    if (indexOrRange !== undefined) {\n      if (typeof indexOrRange === 'string') {\n        indexName = indexOrRange;\n      } else {\n        debugAssert(\n          range === undefined,\n          '3rd argument must not be defined if 2nd is a range.'\n        );\n        range = indexOrRange;\n      }\n    }\n    return { index: indexName, range };\n  }\n\n  private cursor(options: IterateOptions): IDBRequest {\n    let direction: IDBCursorDirection = 'next';\n    if (options.reverse) {\n      direction = 'prev';\n    }\n    if (options.index) {\n      const index = this.store.index(options.index);\n      if (options.keysOnly) {\n        return index.openKeyCursor(options.range, direction);\n      } else {\n        return index.openCursor(options.range, direction);\n      }\n    } else {\n      return this.store.openCursor(options.range, direction);\n    }\n  }\n}\n\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest<R>(request: IDBRequest): PersistencePromise<R> {\n  return new PersistencePromise<R>((resolve, reject) => {\n    request.onsuccess = (event: Event) => {\n      const result = (event.target as IDBRequest).result;\n      resolve(result);\n    };\n\n    request.onerror = (event: Event) => {\n      const error = checkForAndReportiOSError(\n        (event.target as IDBRequest).error!\n      );\n      reject(error);\n    };\n  });\n}\n\n// Guard so we only report the error once.\nlet reportedIOSError = false;\nfunction checkForAndReportiOSError(error: DOMException): Error {\n  const iOSVersion = SimpleDb.getIOSVersion(getUA());\n  if (iOSVersion >= 12.2 && iOSVersion < 13) {\n    const IOS_ERROR =\n      'An internal error was encountered in the Indexed Database server';\n    if (error.message.indexOf(IOS_ERROR) >= 0) {\n      // Wrap error in a more descriptive one.\n      const newError = new FirestoreError(\n        'internal',\n        `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\n          `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\n          `for details and a potential workaround.`\n      );\n      if (!reportedIOSError) {\n        reportedIOSError = true;\n        // Throw a global exception outside of this promise chain, for the user to\n        // potentially catch.\n        setTimeout(() => {\n          throw newError;\n        }, 0);\n      }\n      return newError;\n    }\n  }\n  return error;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FirestoreError } from '../api';\nimport { DocumentMap } from '../model/collections';\nimport {\n  IndexOffset,\n  indexOffsetComparator,\n  newIndexOffsetFromDocument\n} from '../model/field_index';\nimport { debugAssert } from '../util/assert';\nimport { AsyncQueue, DelayedOperation, TimerId } from '../util/async_queue';\nimport { logDebug } from '../util/log';\n\nimport { ignoreIfPrimaryLeaseLoss, LocalStore } from './local_store';\nimport { LocalWriteResult } from './local_store_impl';\nimport { Persistence, Scheduler } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { PersistenceTransaction } from './persistence_transaction';\nimport { isIndexedDbTransactionError } from './simple_db';\n\nconst LOG_TAG = 'IndexBackfiller';\n\n/** How long we wait to try running index backfill after SDK initialization. */\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\n\n/** Minimum amount of time between backfill checks, after the first one. */\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\n\n/** The maximum number of documents to process each time backfill() is called. */\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\n\n/** This class is responsible for the scheduling of Index Backfiller. */\nexport class IndexBackfillerScheduler implements Scheduler {\n  private task: DelayedOperation<void> | null;\n\n  constructor(\n    private readonly asyncQueue: AsyncQueue,\n    private readonly backfiller: IndexBackfiller\n  ) {\n    this.task = null;\n  }\n\n  start(): void {\n    debugAssert(\n      this.task === null,\n      'Cannot start an already started IndexBackfillerScheduler'\n    );\n    this.schedule(INITIAL_BACKFILL_DELAY_MS);\n  }\n\n  stop(): void {\n    if (this.task) {\n      this.task.cancel();\n      this.task = null;\n    }\n  }\n\n  get started(): boolean {\n    return this.task !== null;\n  }\n\n  private schedule(delay: number): void {\n    debugAssert(\n      this.task === null,\n      'Cannot schedule IndexBackfiller while a task is pending'\n    );\n    logDebug(LOG_TAG, `Scheduled in ${delay}ms`);\n    this.task = this.asyncQueue.enqueueAfterDelay(\n      TimerId.IndexBackfill,\n      delay,\n      async () => {\n        this.task = null;\n        try {\n          const documentsProcessed = await this.backfiller.backfill();\n          logDebug(LOG_TAG, `Documents written: ${documentsProcessed}`);\n        } catch (e) {\n          if (isIndexedDbTransactionError(e as Error)) {\n            logDebug(\n              LOG_TAG,\n              'Ignoring IndexedDB error during index backfill: ',\n              e\n            );\n          } else {\n            await ignoreIfPrimaryLeaseLoss(e as FirestoreError);\n          }\n        }\n        await this.schedule(REGULAR_BACKFILL_DELAY_MS);\n      }\n    );\n  }\n}\n\n/** Implements the steps for backfilling indexes. */\nexport class IndexBackfiller {\n  constructor(\n    /**\n     * LocalStore provides access to IndexManager and LocalDocumentView.\n     * These properties will update when the user changes. Consequently,\n     * making a local copy of IndexManager and LocalDocumentView will require\n     * updates over time. The simpler solution is to rely on LocalStore to have\n     * an up-to-date references to IndexManager and LocalDocumentStore.\n     */\n    private readonly localStore: LocalStore,\n    private readonly persistence: Persistence\n  ) {}\n\n  async backfill(\n    maxDocumentsToProcess: number = MAX_DOCUMENTS_TO_PROCESS\n  ): Promise<number> {\n    return this.persistence.runTransaction(\n      'Backfill Indexes',\n      'readwrite-primary',\n      txn => this.writeIndexEntries(txn, maxDocumentsToProcess)\n    );\n  }\n\n  /** Writes index entries until the cap is reached. Returns the number of documents processed. */\n  private writeIndexEntries(\n    transaction: PersistenceTransaction,\n    maxDocumentsToProcess: number\n  ): PersistencePromise<number> {\n    const processedCollectionGroups = new Set<string>();\n    let documentsRemaining = maxDocumentsToProcess;\n    let continueLoop = true;\n    return PersistencePromise.doWhile(\n      () => continueLoop === true && documentsRemaining > 0,\n      () => {\n        return this.localStore.indexManager\n          .getNextCollectionGroupToUpdate(transaction)\n          .next((collectionGroup: string | null) => {\n            if (\n              collectionGroup === null ||\n              processedCollectionGroups.has(collectionGroup)\n            ) {\n              continueLoop = false;\n            } else {\n              logDebug(LOG_TAG, `Processing collection: ${collectionGroup}`);\n              return this.writeEntriesForCollectionGroup(\n                transaction,\n                collectionGroup,\n                documentsRemaining\n              ).next(documentsProcessed => {\n                documentsRemaining -= documentsProcessed;\n                processedCollectionGroups.add(collectionGroup);\n              });\n            }\n          });\n      }\n    ).next(() => maxDocumentsToProcess - documentsRemaining);\n  }\n\n  /**\n   * Writes entries for the provided collection group. Returns the number of documents processed.\n   */\n  private writeEntriesForCollectionGroup(\n    transaction: PersistenceTransaction,\n    collectionGroup: string,\n    documentsRemainingUnderCap: number\n  ): PersistencePromise<number> {\n    // Use the earliest offset of all field indexes to query the local cache.\n    return this.localStore.indexManager\n      .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\n      .next(existingOffset =>\n        this.localStore.localDocuments\n          .getNextDocuments(\n            transaction,\n            collectionGroup,\n            existingOffset,\n            documentsRemainingUnderCap\n          )\n          .next(nextBatch => {\n            const docs: DocumentMap = nextBatch.changes;\n            return this.localStore.indexManager\n              .updateIndexEntries(transaction, docs)\n              .next(() => this.getNewOffset(existingOffset, nextBatch))\n              .next(newOffset => {\n                logDebug(LOG_TAG, `Updating offset: ${newOffset}`);\n                return this.localStore.indexManager.updateCollectionGroup(\n                  transaction,\n                  collectionGroup,\n                  newOffset\n                );\n              })\n              .next(() => docs.size);\n          })\n      );\n  }\n\n  /** Returns the next offset based on the provided documents. */\n  private getNewOffset(\n    existingOffset: IndexOffset,\n    lookupResult: LocalWriteResult\n  ): IndexOffset {\n    let maxOffset: IndexOffset = existingOffset;\n    lookupResult.changes.forEach((key, document) => {\n      const newOffset: IndexOffset = newIndexOffsetFromDocument(document);\n      if (indexOffsetComparator(newOffset, maxOffset) > 0) {\n        maxOffset = newOffset;\n      }\n    });\n    return new IndexOffset(\n      maxOffset.readTime,\n      maxOffset.documentKey,\n      Math.max(lookupResult.batchId, existingOffset.largestBatchId)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ListenSequenceNumber } from './types';\n\n/**\n * `SequenceNumberSyncer` defines the methods required to keep multiple instances of a\n * `ListenSequence` in sync.\n */\nexport interface SequenceNumberSyncer {\n  // Notify the syncer that a new sequence number has been used.\n  writeSequenceNumber(sequenceNumber: ListenSequenceNumber): void;\n  // Setting this property allows the syncer to notify when a sequence number has been used, and\n  // and lets the ListenSequence adjust its internal previous value accordingly.\n  sequenceNumberHandler:\n    | ((sequenceNumber: ListenSequenceNumber) => void)\n    | null;\n}\n\n/**\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\n * exceed. All subsequent calls to next will return increasing values. If provided with a\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\n * well as write out sequence numbers that it produces via `next()`.\n */\nexport class ListenSequence {\n  static readonly INVALID: ListenSequenceNumber = -1;\n\n  private writeNewSequenceNumber?: (\n    newSequenceNumber: ListenSequenceNumber\n  ) => void;\n\n  constructor(\n    private previousValue: ListenSequenceNumber,\n    sequenceNumberSyncer?: SequenceNumberSyncer\n  ) {\n    if (sequenceNumberSyncer) {\n      sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber =>\n        this.setPreviousValue(sequenceNumber);\n      this.writeNewSequenceNumber = sequenceNumber =>\n        sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\n    }\n  }\n\n  private setPreviousValue(\n    externalPreviousValue: ListenSequenceNumber\n  ): ListenSequenceNumber {\n    this.previousValue = Math.max(externalPreviousValue, this.previousValue);\n    return this.previousValue;\n  }\n\n  next(): ListenSequenceNumber {\n    const nextValue = ++this.previousValue;\n    if (this.writeNewSequenceNumber) {\n      this.writeNewSequenceNumber(nextValue);\n    }\n    return nextValue;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Sentinel value that sorts before any Mutation Batch ID. */\nexport const BATCHID_UNKNOWN = -1;\n\n// An Object whose keys and values are strings.\nexport interface StringMap {\n  [key: string]: string;\n}\n\n/**\n * Returns whether a variable is either undefined or null.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/** Returns whether the value represents -0. */\nexport function isNegativeZero(value: number): boolean {\n  // Detect if the value is -0.0. Based on polyfill from\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  return value === 0 && 1 / value === 1 / -0;\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value - The value to test for being an integer and in the safe range\n */\nexport function isSafeInteger(value: unknown): boolean {\n  return (\n    typeof value === 'number' &&\n    Number.isInteger(value) &&\n    !isNegativeZero(value) &&\n    value <= Number.MAX_SAFE_INTEGER &&\n    value >= Number.MIN_SAFE_INTEGER\n  );\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/** The subset of the browser's Window interface used by the SDK. */\nexport interface WindowLike {\n  readonly localStorage: Storage;\n  readonly indexedDB: IDBFactory | null;\n  addEventListener(type: string, listener: EventListener): void;\n  removeEventListener(type: string, listener: EventListener): void;\n}\n\n/** The subset of the browser's Document interface used by the SDK. */\nexport interface DocumentLike {\n  readonly visibilityState: DocumentVisibilityState;\n  addEventListener(type: string, listener: EventListener): void;\n  removeEventListener(type: string, listener: EventListener): void;\n}\n\n/**\n * @beta\n * Utility type to create an type that only allows one\n * property of the Type param T to be set.\n *\n * @example\n * ```\n * type XorY = OneOf<{ x: unknown, y: unknown }>\n * let a = { x: \"foo\" }           // OK\n * let b = { y: \"foo\" }           // OK\n * let c = { a: \"foo\", y: \"foo\" } // Not OK\n * ```\n */\nexport type OneOf<T> = {\n  [K in keyof T]: Pick<T, K> & {\n    [P in Exclude<keyof T, K>]?: undefined;\n  };\n}[keyof T];\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ResourcePath } from '../model/path';\nimport { fail, hardAssert } from '../util/assert';\n\n/**\n * Helpers for dealing with resource paths stored in IndexedDB.\n *\n * Resource paths in their canonical string form do not sort as the server\n * sorts them. Specifically the server splits paths into segments first and then\n * sorts, putting end-of-segment before any character. In a UTF-8 string\n * encoding the slash ('/') that denotes the end-of-segment naturally comes\n * after other characters so the intent here is to encode the path delimiters in\n * such a way that the resulting strings sort naturally.\n *\n * Resource paths are also used for prefix scans so it's important to\n * distinguish whole segments from any longer segments of which they might be a\n * prefix. For example, it's important to make it possible to scan documents in\n * a collection \"foo\" without encountering documents in a collection \"foobar\".\n *\n * Separate from the concerns about resource path ordering and separation,\n * On Android, SQLite imposes additional restrictions since it does not handle\n * keys with embedded NUL bytes particularly well. Rather than change the\n * implementation we keep the encoding identical to keep the ports similar.\n *\n * Taken together this means resource paths when encoded for storage in\n * IndexedDB have the following characteristics:\n *\n *   * Segment separators (\"/\") sort before everything else.\n *   * All paths have a trailing separator.\n *   * NUL bytes do not exist in the output, since IndexedDB doesn't treat them\n * well.\n *\n * Therefore resource paths are encoded into string form using the following\n * rules:\n *\n *   * '\\x01' is used as an escape character.\n *   * Path separators are encoded as \"\\x01\\x01\"\n *   * NUL bytes are encoded as \"\\x01\\x10\"\n *   * '\\x01' is encoded as \"\\x01\\x11\"\n *\n * This encoding leaves some room between path separators and the NUL byte\n * just in case we decide to support integer document ids after all.\n *\n * Note that characters treated specially by the backend ('.', '/', and '~')\n * are not treated specially here. This class assumes that any unescaping of\n * resource path strings into actual ResourcePath objects will handle these\n * characters there.\n */\nexport type EncodedResourcePath = string;\n\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nexport function encodeResourcePath(path: ResourcePath): EncodedResourcePath {\n  let result = '';\n  for (let i = 0; i < path.length; i++) {\n    if (result.length > 0) {\n      result = encodeSeparator(result);\n    }\n    result = encodeSegment(path.get(i), result);\n  }\n  return encodeSeparator(result);\n}\n\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment: string, resultBuf: string): string {\n  let result = resultBuf;\n  const length = segment.length;\n  for (let i = 0; i < length; i++) {\n    const c = segment.charAt(i);\n    switch (c) {\n      case '\\0':\n        result += escapeChar + encodedNul;\n        break;\n      case escapeChar:\n        result += escapeChar + encodedEscape;\n        break;\n      default:\n        result += c;\n    }\n  }\n  return result;\n}\n\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result: string): string {\n  return result + escapeChar + encodedSeparatorChar;\n}\n\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nexport function decodeResourcePath(path: EncodedResourcePath): ResourcePath {\n  // Event the empty path must encode as a path of at least length 2. A path\n  // with exactly 2 must be the empty path.\n  const length = path.length;\n  hardAssert(length >= 2, 0xfb98, 'Invalid path', { path });\n  if (length === 2) {\n    hardAssert(\n      path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar,\n      0xdb51,\n      'Non-empty path had length 2',\n      { path }\n    );\n    return ResourcePath.emptyPath();\n  }\n\n  // Escape characters cannot exist past the second-to-last position in the\n  // source value.\n  const lastReasonableEscapeIndex = length - 2;\n\n  const segments: string[] = [];\n  let segmentBuilder = '';\n\n  for (let start = 0; start < length; ) {\n    // The last two characters of a valid encoded path must be a separator, so\n    // there must be an end to this segment.\n    const end = path.indexOf(escapeChar, start);\n    if (end < 0 || end > lastReasonableEscapeIndex) {\n      fail(0xc553, 'Invalid encoded resource path', { path });\n    }\n\n    const next = path.charAt(end + 1);\n    switch (next) {\n      case encodedSeparatorChar:\n        const currentPiece = path.substring(start, end);\n        let segment;\n        if (segmentBuilder.length === 0) {\n          // Avoid copying for the common case of a segment that excludes \\0\n          // and \\001\n          segment = currentPiece;\n        } else {\n          segmentBuilder += currentPiece;\n          segment = segmentBuilder;\n          segmentBuilder = '';\n        }\n        segments.push(segment);\n        break;\n      case encodedNul:\n        segmentBuilder += path.substring(start, end);\n        segmentBuilder += '\\0';\n        break;\n      case encodedEscape:\n        // The escape character can be used in the output to encode itself.\n        segmentBuilder += path.substring(start, end + 1);\n        break;\n      default:\n        fail(0xeeef, 'Invalid encoded resource path', { path });\n    }\n\n    start = end + 2;\n  }\n\n  return new ResourcePath(segments);\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document as ProtoDocument } from '../protos/firestore_proto_api';\n\nimport { DbNoDocument, DbUnknownDocument } from './indexeddb_schema';\nimport { DbTimestampKey } from './indexeddb_sentinels';\n\n// This file contains older schema definitions for object stores that were\n// migrated to newer schema versions. These object stores should only be used\n// during schema migrations.\n\nexport interface DbRemoteDocument {\n  unknownDocument?: DbUnknownDocument;\n  noDocument?: DbNoDocument;\n  document?: ProtoDocument;\n  hasCommittedMutations?: boolean;\n  readTime?: DbTimestampKey;\n  parentPath?: string[];\n}\n\nexport type DbRemoteDocumentKey = string[];\nexport const DbRemoteDocumentStore = 'remoteDocuments';\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchId, TargetId } from '../core/types';\nimport { ResourcePath } from '../model/path';\nimport { fail } from '../util/assert';\n\nimport {\n  EncodedResourcePath,\n  encodeResourcePath\n} from './encoded_resource_path';\nimport { DbDocumentMutation } from './indexeddb_schema';\nimport { DbRemoteDocumentStore as DbRemoteDocumentStoreLegacy } from './indexeddb_schema_legacy';\n\n// This file contains static constants and helper functions for IndexedDB.\n// It is split from indexeddb_schema to allow for minification.\n\n/** A timestamp type that can be used in IndexedDb keys. */\nexport type DbTimestampKey = [/* seconds */ number, /* nanos */ number];\n\n// The key for the singleton object in the DbPrimaryClient is a single string.\nexport type DbPrimaryClientKey = typeof DbPrimaryClientKey;\n\n/**\n * Name of the IndexedDb object store.\n *\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\n * older clients that only supported single locked access to the persistence\n * layer.\n */\nexport const DbPrimaryClientStore = 'owner';\n\n/**\n * The key string used for the single object that exists in the\n * DbPrimaryClient store.\n */\n\nexport const DbPrimaryClientKey = 'owner';\n\n/** Object keys in the 'mutationQueues' store are userId strings. */\nexport type DbMutationQueueKey = string;\n\n/** Name of the IndexedDb object store.  */\nexport const DbMutationQueueStore = 'mutationQueues';\n\n/** Keys are automatically assigned via the userId property. */\nexport const DbMutationQueueKeyPath = 'userId';\n\n/** The 'mutations' store  is keyed by batch ID. */\nexport type DbMutationBatchKey = BatchId;\n\n/** Name of the IndexedDb object store.  */\nexport const DbMutationBatchStore = 'mutations';\n\n/** Keys are automatically assigned via the userId, batchId properties. */\nexport const DbMutationBatchKeyPath = 'batchId';\n\n/** The index name for lookup of mutations by user. */\n\nexport const DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\n\n/** The user mutations index is keyed by [userId, batchId] pairs. */\nexport const DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\n\n/**\n * The key for a db document mutation, which is made up of a userID, path, and\n * batchId. Note that the path must be serialized into a form that indexedDB can\n * sort.\n */\nexport type DbDocumentMutationKey = [string, EncodedResourcePath, BatchId];\n\n/**\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n * over all of a user's document mutations.\n */\nexport function newDbDocumentMutationPrefixForUser(userId: string): [string] {\n  return [userId];\n}\n\n/**\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n * index to iterate over all at document mutations for a given path or lower.\n */\nexport function newDbDocumentMutationPrefixForPath(\n  userId: string,\n  path: ResourcePath\n): [string, EncodedResourcePath] {\n  return [userId, encodeResourcePath(path)];\n}\n\n/**\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\n * and deleting into the DbDocumentMutations index.\n */\nexport function newDbDocumentMutationKey(\n  userId: string,\n  path: ResourcePath,\n  batchId: BatchId\n): DbDocumentMutationKey {\n  return [userId, encodeResourcePath(path), batchId];\n}\n\n/**\n * Because we store all the useful information for this store in the key,\n * there is no useful information to store as the value. The raw (unencoded)\n * path cannot be stored because IndexedDb doesn't store prototype\n * information.\n */\nexport const DbDocumentMutationPlaceholder: DbDocumentMutation = {};\n\nexport const DbDocumentMutationStore = 'documentMutations';\n\nexport const DbRemoteDocumentStore = 'remoteDocumentsV14';\n\n/**\n * A key in the 'remoteDocumentsV14' object store is an array containing the\n * collection path, the collection group, the read time and the document id.\n */\nexport type DbRemoteDocumentKey = [\n  /** path to collection */ string[],\n  /** collection group */ string,\n  /** read time */ DbTimestampKey,\n  /** document ID */ string\n];\n\n/**\n * The primary key of the remote documents store, which allows for efficient\n * access by collection path and read time.\n */\nexport const DbRemoteDocumentKeyPath = [\n  'prefixPath',\n  'collectionGroup',\n  'readTime',\n  'documentId'\n];\n\n/** An index that provides access to documents by key. */\nexport const DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\n\nexport const DbRemoteDocumentDocumentKeyIndexPath = [\n  'prefixPath',\n  'collectionGroup',\n  'documentId'\n];\n\n/**\n * An index that provides access to documents by collection group and read\n * time.\n *\n * This index is used by the index backfiller.\n */\nexport const DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\n\nexport const DbRemoteDocumentCollectionGroupIndexPath = [\n  'collectionGroup',\n  'readTime',\n  'prefixPath',\n  'documentId'\n];\n\nexport const DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\n\nexport const DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\n\nexport type DbRemoteDocumentGlobalKey = typeof DbRemoteDocumentGlobalKey;\n\n/**\n * A key in the 'targets' object store is a targetId of the query.\n */\nexport type DbTargetKey = TargetId;\n\nexport const DbTargetStore = 'targets';\n\n/** Keys are automatically assigned via the targetId property. */\nexport const DbTargetKeyPath = 'targetId';\n\n/** The name of the queryTargets index. */\nexport const DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\n\n/**\n * The index of all canonicalIds to the targets that they match. This is not\n * a unique mapping because canonicalId does not promise a unique name for all\n * possible queries, so we append the targetId to make the mapping unique.\n */\nexport const DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\n\n/**\n * The key for a DbTargetDocument, containing a targetId and an encoded resource\n * path.\n */\nexport type DbTargetDocumentKey = [TargetId, EncodedResourcePath];\n\n/** Name of the IndexedDb object store.  */\nexport const DbTargetDocumentStore = 'targetDocuments';\n\n/** Keys are automatically assigned via the targetId, path properties. */\nexport const DbTargetDocumentKeyPath = ['targetId', 'path'];\n\n/** The index name for the reverse index. */\nexport const DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\n\n/** We also need to create the reverse index for these properties. */\nexport const DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\n\n/**\n * The type to represent the single allowed key for the DbTargetGlobal store.\n */\nexport type DbTargetGlobalKey = typeof DbTargetGlobalKey;\n\n/**\n * The key string used for the single object that exists in the\n * DbTargetGlobal store.\n */\nexport const DbTargetGlobalKey = 'targetGlobalKey';\n\nexport const DbTargetGlobalStore = 'targetGlobal';\n\n/**\n * The key for a DbCollectionParent entry, containing the collection ID\n * and the parent path that contains it. Note that the parent path will be an\n * empty path in the case of root-level collections.\n */\nexport type DbCollectionParentKey = [string, EncodedResourcePath];\n\n/** Name of the IndexedDb object store. */\nexport const DbCollectionParentStore = 'collectionParents';\n\n/** Keys are automatically assigned via the collectionId, parent properties. */\nexport const DbCollectionParentKeyPath = ['collectionId', 'parent'];\n\n/** Name of the IndexedDb object store. */\nexport const DbClientMetadataStore = 'clientMetadata';\n\n/** Keys are automatically assigned via the clientId properties. */\nexport const DbClientMetadataKeyPath = 'clientId';\n\n/** Object keys in the 'clientMetadata' store are clientId strings. */\nexport type DbClientMetadataKey = string;\n\nexport type DbBundlesKey = string;\n\n/** Name of the IndexedDb object store. */\nexport const DbBundleStore = 'bundles';\n\nexport const DbBundleKeyPath = 'bundleId';\n\nexport type DbNamedQueriesKey = string;\n\n/** Name of the IndexedDb object store. */\nexport const DbNamedQueryStore = 'namedQueries';\n\nexport const DbNamedQueryKeyPath = 'name';\n\n/** The key for each index consisting of just the index id. */\nexport type DbIndexConfigurationKey = number;\n\n/** Name of the IndexedDb object store. */\nexport const DbIndexConfigurationStore = 'indexConfiguration';\n\nexport const DbIndexConfigurationKeyPath = 'indexId';\n\n/**\n * An index that provides access to the index configurations by collection\n * group.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nexport const DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\n\nexport const DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\n\n/** The key for each index state consisting of the index id and its user id. */\nexport type DbIndexStateKey = [number, string];\n\n/** Name of the IndexedDb object store. */\nexport const DbIndexStateStore = 'indexState';\n\nexport const DbIndexStateKeyPath = ['indexId', 'uid'];\n\n/**\n * An index that provides access to documents in a collection sorted by last\n * update time. Used by the backfiller.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nexport const DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\n\nexport const DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\n\n/**\n * Representation of a byte array that is safe for\n * use in an IndexedDb key. The value is either\n * a \"sortable byte string\", which is key safe in\n * Safari/WebKit, or the value is a Uint8Array,\n * which is key safe in other browsers.\n */\nexport type KeySafeBytes = Uint8Array | string;\n\n/**\n * The key for each index entry consists of the index id and its user id,\n * the encoded array and directional value for the indexed fields as well as\n * an ordered and an encoded document path for the indexed document.\n */\nexport type DbIndexEntryKey = [\n  number,\n  string,\n  KeySafeBytes,\n  KeySafeBytes,\n  KeySafeBytes,\n  string[]\n];\n\n/** Name of the IndexedDb object store. */\nexport const DbIndexEntryStore = 'indexEntries';\n\nexport const DbIndexEntryKeyPath = [\n  'indexId',\n  'uid',\n  'arrayValue',\n  'directionalValue',\n  'orderedDocumentKey',\n  'documentKey'\n];\n\nexport const DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\n\nexport const DbIndexEntryDocumentKeyIndexPath = [\n  'indexId',\n  'uid',\n  'orderedDocumentKey'\n];\n\nexport type DbDocumentOverlayKey = [\n  /* userId */ string,\n  /* collectionPath */ string,\n  /* documentId */ string\n];\n\n/** Name of the IndexedDb object store. */\nexport const DbDocumentOverlayStore = 'documentOverlays';\n\nexport const DbDocumentOverlayKeyPath = [\n  'userId',\n  'collectionPath',\n  'documentId'\n];\n\nexport const DbDocumentOverlayCollectionPathOverlayIndex =\n  'collectionPathOverlayIndex';\n\nexport const DbDocumentOverlayCollectionPathOverlayIndexPath = [\n  'userId',\n  'collectionPath',\n  'largestBatchId'\n];\n\nexport const DbDocumentOverlayCollectionGroupOverlayIndex =\n  'collectionGroupOverlayIndex';\n\nexport const DbDocumentOverlayCollectionGroupOverlayIndexPath = [\n  'userId',\n  'collectionGroup',\n  'largestBatchId'\n];\n\n/** Name of the IndexedDb object store. */\nexport const DbGlobalsStore = 'globals';\n\nexport const DbGlobalsKeyPath = 'name';\n\n/** Names of global values */\nexport type DbGlobalsKey = 'sessionToken';\n\n// Visible for testing\nexport const V1_STORES = [\n  DbMutationQueueStore,\n  DbMutationBatchStore,\n  DbDocumentMutationStore,\n  DbRemoteDocumentStoreLegacy,\n  DbTargetStore,\n  DbPrimaryClientStore,\n  DbTargetGlobalStore,\n  DbTargetDocumentStore\n];\n\n// Visible for testing\nexport const V3_STORES = V1_STORES;\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\nexport const V4_STORES = [...V3_STORES, DbClientMetadataStore];\nexport const V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\nexport const V8_STORES = [...V6_STORES, DbCollectionParentStore];\nexport const V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\nexport const V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\nexport const V13_STORES = [\n  DbMutationQueueStore,\n  DbMutationBatchStore,\n  DbDocumentMutationStore,\n  DbRemoteDocumentStore,\n  DbTargetStore,\n  DbPrimaryClientStore,\n  DbTargetGlobalStore,\n  DbTargetDocumentStore,\n  DbClientMetadataStore,\n  DbRemoteDocumentGlobalStore,\n  DbCollectionParentStore,\n  DbBundleStore,\n  DbNamedQueryStore,\n  DbDocumentOverlayStore\n];\nexport const V14_STORES = V13_STORES;\nexport const V15_STORES = [\n  ...V14_STORES,\n  DbIndexConfigurationStore,\n  DbIndexStateStore,\n  DbIndexEntryStore\n];\nexport const V16_STORES = V15_STORES;\nexport const V17_STORES = [...V15_STORES, DbGlobalsStore];\nexport const V18_STORES = V17_STORES;\n\n/**\n * The list of all default IndexedDB stores used throughout the SDK. This is\n * used when creating transactions so that access across all stores is done\n * atomically.\n */\nexport const ALL_STORES = V12_STORES;\n\n/** Returns the object stores for the provided schema. */\nexport function getObjectStores(schemaVersion: number): string[] {\n  if (schemaVersion === 18) {\n    return V18_STORES;\n  } else if (schemaVersion === 17) {\n    return V17_STORES;\n  } else if (schemaVersion === 16) {\n    return V16_STORES;\n  } else if (schemaVersion === 15) {\n    return V15_STORES;\n  } else if (schemaVersion === 14) {\n    return V14_STORES;\n  } else if (schemaVersion === 13) {\n    return V13_STORES;\n  } else if (schemaVersion === 12) {\n    return V12_STORES;\n  } else if (schemaVersion === 11) {\n    return V11_STORES;\n  } else {\n    fail(0xeb55, 'Only schema versions >11 are supported');\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ListenSequenceNumber } from '../core/types';\nimport { debugCast } from '../util/assert';\n\nimport { PersistenceTransaction } from './persistence_transaction';\nimport { SimpleDb, SimpleDbStore, SimpleDbTransaction } from './simple_db';\n\nexport class IndexedDbTransaction extends PersistenceTransaction {\n  constructor(\n    readonly simpleDbTransaction: SimpleDbTransaction,\n    readonly currentSequenceNumber: ListenSequenceNumber\n  ) {\n    super();\n  }\n}\n\nexport function getStore<Key extends IDBValidKey, Value>(\n  txn: PersistenceTransaction,\n  store: string\n): SimpleDbStore<Key, Value> {\n  const indexedDbTransaction = debugCast(txn, IndexedDbTransaction);\n  return SimpleDb.getStore<Key, Value>(\n    indexedDbTransaction.simpleDbTransaction,\n    store\n  );\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from './assert';\n\nexport interface Dict<V> {\n  [stringKey: string]: V;\n}\n\nexport function objectSize(obj: object): number {\n  let count = 0;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      count++;\n    }\n  }\n  return count;\n}\n\nexport function forEach<V>(\n  obj: Record<string, V> | undefined,\n  fn: (key: string, val: V) => void\n): void {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      fn(key, obj[key]);\n    }\n  }\n}\n\nexport function mapToArray<V, R>(\n  obj: Dict<V>,\n  fn: (element: V, key: string, obj: Dict<V>) => R\n): R[] {\n  const result: R[] = [];\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result.push(fn(obj[key], key, obj));\n    }\n  }\n  return result;\n}\n\nexport function isEmpty<V>(obj: Dict<V>): boolean {\n  debugAssert(\n    obj != null && typeof obj === 'object',\n    'isEmpty() expects object parameter.'\n  );\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert, fail } from './assert';\n\n/*\n * Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\nexport interface Entry<K, V> {\n  key: K;\n  value: V;\n}\n\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nexport class SortedMap<K, V> {\n  // visible for testing\n  root: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  constructor(\n    public comparator: Comparator<K>,\n    root?: LLRBNode<K, V> | LLRBEmptyNode<K, V>\n  ) {\n    this.root = root ? root : LLRBNode.EMPTY;\n  }\n\n  // Returns a copy of the map, with the specified key/value added or replaced.\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .insert(key, value, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns a copy of the map, with the specified key removed.\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .remove(key, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns the value of the node with the given key, or null.\n  get(key: K): V | null {\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  // Returns the index of the element in this sorted map, or -1 if it doesn't\n  // exist.\n  indexOf(key: K): number {\n    // Number of nodes that were pruned when descending right\n    let prunedNodes = 0;\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return prunedNodes + node.left.size;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        // Count all nodes left of the node plus the node itself\n        prunedNodes += node.left.size + 1;\n        node = node.right;\n      }\n    }\n    // Node not found\n    return -1;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  // Returns the total number of nodes in the map.\n  get size(): number {\n    return this.root.size;\n  }\n\n  // Returns the minimum key in the map.\n  minKey(): K | null {\n    return this.root.minKey();\n  }\n\n  // Returns the maximum key in the map.\n  maxKey(): K | null {\n    return this.root.maxKey();\n  }\n\n  // Traverses the map in key order and calls the specified action function\n  // for each key/value pair. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).inorderTraversal(action);\n  }\n\n  forEach(fn: (k: K, v: V) => void): void {\n    this.inorderTraversal((k, v) => {\n      fn(k, v);\n      return false;\n    });\n  }\n\n  toString(): string {\n    const descriptions: string[] = [];\n    this.inorderTraversal((k, v) => {\n      descriptions.push(`${k}:${v}`);\n      return false;\n    });\n    return `{${descriptions.join(', ')}}`;\n  }\n\n  // Traverses the map in reverse key order and calls the specified action\n  // function for each key/value pair. If action returns true, traversal is\n  // aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).reverseTraversal(action);\n  }\n\n  // Returns an iterator over the SortedMap.\n  getIterator(): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, null, this.comparator, false);\n  }\n\n  getIteratorFrom(key: K): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, key, this.comparator, false);\n  }\n\n  getReverseIterator(): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, null, this.comparator, true);\n  }\n\n  getReverseIteratorFrom(key: K): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, key, this.comparator, true);\n  }\n} // end SortedMap\n\n// An iterator over an LLRBNode.\nexport class SortedMapIterator<K, V> {\n  private isReverse: boolean;\n  private nodeStack: Array<LLRBNode<K, V> | LLRBEmptyNode<K, V>>;\n\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    isReverse: boolean\n  ) {\n    this.isReverse = isReverse;\n    this.nodeStack = [];\n\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (startKey && isReverse) {\n        cmp *= -1;\n      }\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack,\n        // but stop iterating;\n        this.nodeStack.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move\n        // to the next one\n        this.nodeStack.push(node);\n        if (this.isReverse) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): Entry<K, V> {\n    debugAssert(\n      this.nodeStack.length > 0,\n      'getNext() called on iterator when hasNext() is false.'\n    );\n\n    let node = this.nodeStack.pop()!;\n    const result = { key: node.key, value: node.value };\n\n    if (this.isReverse) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack.length > 0;\n  }\n\n  peek(): Entry<K, V> | null {\n    if (this.nodeStack.length === 0) {\n      return null;\n    }\n\n    const node = this.nodeStack[this.nodeStack.length - 1];\n    return { key: node.key, value: node.value };\n  }\n} // end SortedMapIterator\n\n// Represents a node in a Left-leaning Red-Black tree.\nexport class LLRBNode<K, V> {\n  readonly color: boolean;\n  readonly left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly size: number;\n\n  // Empty node is shared between all LLRB trees.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static EMPTY: LLRBEmptyNode<any, any> = null as any;\n\n  static RED = true;\n  static BLACK = false;\n\n  constructor(\n    public key: K,\n    public value: V,\n    color?: boolean,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V>\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left = left != null ? left : LLRBNode.EMPTY;\n    this.right = right != null ? right : LLRBNode.EMPTY;\n    this.size = this.left.size + 1 + this.right.size;\n  }\n\n  // Returns a copy of the current node, optionally replacing pieces of it.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBNode<K, V> {\n    return new LLRBNode<K, V>(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  // Traverses the tree in key order and calls the specified action function\n  // for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.left as LLRBNode<K, V>).inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.right as LLRBNode<K, V>).inorderTraversal(action)\n    );\n  }\n\n  // Traverses the tree in reverse key order and calls the specified action\n  // function for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.right as LLRBNode<K, V>).reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.left as LLRBNode<K, V>).reverseTraversal(action)\n    );\n  }\n\n  // Returns the minimum node in the tree.\n  private min(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min();\n    }\n  }\n\n  // Returns the maximum key in the tree.\n  minKey(): K | null {\n    return this.min().key;\n  }\n\n  // Returns the maximum key in the tree.\n  maxKey(): K | null {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  // Returns new tree, with the key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let n: LLRBNode<K, V> = this;\n    const cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp();\n  }\n\n  private removeMin(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return LLRBNode.EMPTY;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed() && !n.left.left.isRed()) {\n      n = n.moveRedLeft();\n    }\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin(), null);\n    return n.fixUp();\n  }\n\n  // Returns new tree, with the specified item removed.\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let smallest: LLRBNode<K, V>;\n    let n: LLRBNode<K, V> = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n        n = n.moveRedLeft();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed()) {\n        n = n.rotateRight();\n      }\n      if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n        n = n.moveRedRight();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return LLRBNode.EMPTY;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp();\n  }\n\n  isRed(): boolean {\n    return this.color;\n  }\n\n  // Returns new tree after performing any needed rotations.\n  private fixUp(): LLRBNode<K, V> {\n    let n: LLRBNode<K, V> = this;\n    if (n.right.isRed() && !n.left.isRed()) {\n      n = n.rotateLeft();\n    }\n    if (n.left.isRed() && n.left.left.isRed()) {\n      n = n.rotateRight();\n    }\n    if (n.left.isRed() && n.right.isRed()) {\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private moveRedLeft(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.right.left.isRed()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight()\n      );\n      n = n.rotateLeft();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private moveRedRight(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.left.left.isRed()) {\n      n = n.rotateRight();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private rotateLeft(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return (this.right as LLRBNode<K, V>).copy(\n      null,\n      null,\n      this.color,\n      nl,\n      null\n    );\n  }\n\n  private rotateRight(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return (this.left as LLRBNode<K, V>).copy(null, null, this.color, null, nr);\n  }\n\n  private colorFlip(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    const blackDepth = this.check();\n    if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // In a balanced RB tree, the black-depth (number of black nodes) from root to\n  // leaves is equal on both sides.  This function verifies that or asserts.\n  protected check(): number {\n    if (this.isRed() && this.left.isRed()) {\n      throw fail(0xaad2, 'Red node has red child', {\n        key: this.key,\n        value: this.value\n      });\n    }\n    if (this.right.isRed()) {\n      throw fail(0x3721, 'Right child of (`key`, `value`) is red', {\n        key: this.key,\n        value: this.value\n      });\n    }\n    const blackDepth = (this.left as LLRBNode<K, V>).check();\n    if (blackDepth !== (this.right as LLRBNode<K, V>).check()) {\n      throw fail(0x6d2d, 'Black depths differ');\n    } else {\n      return blackDepth + (this.isRed() ? 0 : 1);\n    }\n  }\n} // end LLRBNode\n\n// Represents an empty node (a leaf node in the Red-Black Tree).\nexport class LLRBEmptyNode<K, V> {\n  get key(): never {\n    throw fail(0xe1a6, 'LLRBEmptyNode has no key.');\n  }\n  get value(): never {\n    throw fail(0x3f0d, 'LLRBEmptyNode has no value.');\n  }\n  get color(): never {\n    throw fail(0x4157, 'LLRBEmptyNode has no color.');\n  }\n  get left(): never {\n    throw fail(0x741e, 'LLRBEmptyNode has no left child.');\n  }\n  get right(): never {\n    throw fail(0x901e, 'LLRBEmptyNode has no right child.');\n  }\n  size = 0;\n\n  // Returns a copy of the current node.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  // Returns a copy of the tree, with the specified key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode<K, V>(key, value);\n  }\n\n  // Returns a copy of the tree, with the specified key removed.\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  inorderTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  reverseTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  minKey(): K | null {\n    return null;\n  }\n\n  maxKey(): K | null {\n    return null;\n  }\n\n  isRed(): boolean {\n    return false;\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    return true;\n  }\n\n  protected check(): 0 {\n    return 0;\n  }\n} // end LLRBEmptyNode\n\nLLRBNode.EMPTY = new LLRBEmptyNode<unknown, unknown>();\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SortedMap, SortedMapIterator } from './sorted_map';\n\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nexport class SortedSet<T> {\n  private data: SortedMap<T, boolean>;\n\n  constructor(private comparator: (left: T, right: T) => number) {\n    this.data = new SortedMap<T, boolean>(this.comparator);\n  }\n\n  has(elem: T): boolean {\n    return this.data.get(elem) !== null;\n  }\n\n  first(): T | null {\n    return this.data.minKey();\n  }\n\n  last(): T | null {\n    return this.data.maxKey();\n  }\n\n  get size(): number {\n    return this.data.size;\n  }\n\n  indexOf(elem: T): number {\n    return this.data.indexOf(elem);\n  }\n\n  /** Iterates elements in order defined by \"comparator\" */\n  forEach(cb: (elem: T) => void): void {\n    this.data.inorderTraversal((k: T, v: boolean) => {\n      cb(k);\n      return false;\n    });\n  }\n\n  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\n  forEachInRange(range: [T, T], cb: (elem: T) => void): void {\n    const iter = this.data.getIteratorFrom(range[0]);\n    while (iter.hasNext()) {\n      const elem = iter.getNext();\n      if (this.comparator(elem.key, range[1]) >= 0) {\n        return;\n      }\n      cb(elem.key);\n    }\n  }\n\n  /**\n   * Iterates over `elem`s such that: start &lt;= elem until false is returned.\n   */\n  forEachWhile(cb: (elem: T) => boolean, start?: T): void {\n    let iter: SortedMapIterator<T, boolean>;\n    if (start !== undefined) {\n      iter = this.data.getIteratorFrom(start);\n    } else {\n      iter = this.data.getIterator();\n    }\n    while (iter.hasNext()) {\n      const elem = iter.getNext();\n      const result = cb(elem.key);\n      if (!result) {\n        return;\n      }\n    }\n  }\n\n  /** Finds the least element greater than or equal to `elem`. */\n  firstAfterOrEqual(elem: T): T | null {\n    const iter = this.data.getIteratorFrom(elem);\n    return iter.hasNext() ? iter.getNext().key : null;\n  }\n\n  getIterator(): SortedSetIterator<T> {\n    return new SortedSetIterator<T>(this.data.getIterator());\n  }\n\n  getIteratorFrom(key: T): SortedSetIterator<T> {\n    return new SortedSetIterator<T>(this.data.getIteratorFrom(key));\n  }\n\n  /** Inserts or updates an element */\n  add(elem: T): SortedSet<T> {\n    return this.copy(this.data.remove(elem).insert(elem, true));\n  }\n\n  /** Deletes an element */\n  delete(elem: T): SortedSet<T> {\n    if (!this.has(elem)) {\n      return this;\n    }\n    return this.copy(this.data.remove(elem));\n  }\n\n  isEmpty(): boolean {\n    return this.data.isEmpty();\n  }\n\n  unionWith(other: SortedSet<T>): SortedSet<T> {\n    let result: SortedSet<T> = this;\n\n    // Make sure `result` always refers to the larger one of the two sets.\n    if (result.size < other.size) {\n      result = other;\n      other = this;\n    }\n\n    other.forEach(elem => {\n      result = result.add(elem);\n    });\n    return result;\n  }\n\n  isEqual(other: SortedSet<T>): boolean {\n    if (!(other instanceof SortedSet)) {\n      return false;\n    }\n    if (this.size !== other.size) {\n      return false;\n    }\n\n    const thisIt = this.data.getIterator();\n    const otherIt = other.data.getIterator();\n    while (thisIt.hasNext()) {\n      const thisElem = thisIt.getNext().key;\n      const otherElem = otherIt.getNext().key;\n      if (this.comparator(thisElem, otherElem) !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  toArray(): T[] {\n    const res: T[] = [];\n    this.forEach(targetId => {\n      res.push(targetId);\n    });\n    return res;\n  }\n\n  toString(): string {\n    const result: T[] = [];\n    this.forEach(elem => result.push(elem));\n    return 'SortedSet(' + result.toString() + ')';\n  }\n\n  private copy(data: SortedMap<T, boolean>): SortedSet<T> {\n    const result = new SortedSet(this.comparator);\n    result.data = data;\n    return result;\n  }\n}\n\nexport class SortedSetIterator<T> {\n  constructor(private iter: SortedMapIterator<T, boolean>) {}\n\n  getNext(): T {\n    return this.iter.getNext().key;\n  }\n\n  hasNext(): boolean {\n    return this.iter.hasNext();\n  }\n}\n\n/**\n * Compares two sorted sets for equality using their natural ordering. The\n * method computes the intersection and invokes `onAdd` for every element that\n * is in `after` but not `before`. `onRemove` is invoked for every element in\n * `before` but missing from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original set.\n * @param after - The elements to diff against the original set.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nexport function diffSortedSets<T>(\n  before: SortedSet<T>,\n  after: SortedSet<T>,\n  comparator: (l: T, r: T) => number,\n  onAdd: (entry: T) => void,\n  onRemove: (entry: T) => void\n): void {\n  const beforeIt = before.getIterator();\n  const afterIt = after.getIterator();\n\n  let beforeValue = advanceIterator(beforeIt);\n  let afterValue = advanceIterator(afterIt);\n\n  // Walk through the two sets at the same time, using the ordering defined by\n  // `comparator`.\n  while (beforeValue || afterValue) {\n    let added = false;\n    let removed = false;\n\n    if (beforeValue && afterValue) {\n      const cmp = comparator(beforeValue, afterValue);\n      if (cmp < 0) {\n        // The element was removed if the next element in our ordered\n        // walkthrough is only in `before`.\n        removed = true;\n      } else if (cmp > 0) {\n        // The element was added if the next element in our ordered walkthrough\n        // is only in `after`.\n        added = true;\n      }\n    } else if (beforeValue != null) {\n      removed = true;\n    } else {\n      added = true;\n    }\n\n    if (added) {\n      onAdd(afterValue!);\n      afterValue = advanceIterator(afterIt);\n    } else if (removed) {\n      onRemove(beforeValue!);\n      beforeValue = advanceIterator(beforeIt);\n    } else {\n      beforeValue = advanceIterator(beforeIt);\n      afterValue = advanceIterator(afterIt);\n    }\n  }\n}\n\n/**\n * Returns the next element from the iterator or `undefined` if none available.\n */\nfunction advanceIterator<T>(it: SortedSetIterator<T>): T | undefined {\n  return it.hasNext() ? it.getNext() : undefined;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from '../util/assert';\nimport { arrayEquals } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\nimport { FieldPath } from './path';\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nexport class FieldMask {\n  constructor(readonly fields: FieldPath[]) {\n    // TODO(dimond): validation of FieldMask\n    // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n    fields.sort(FieldPath.comparator);\n    debugAssert(\n      !fields.some((v, i) => i !== 0 && v.isEqual(fields[i - 1])),\n      'FieldMask contains field that is not unique: ' +\n        fields.find((v, i) => i !== 0 && v.isEqual(fields[i - 1]))!\n    );\n  }\n\n  static empty(): FieldMask {\n    return new FieldMask([]);\n  }\n\n  /**\n   * Returns a new FieldMask object that is the result of adding all the given\n   * fields paths to this field mask.\n   */\n  unionWith(extraFields: FieldPath[]): FieldMask {\n    let mergedMaskSet = new SortedSet<FieldPath>(FieldPath.comparator);\n    for (const fieldPath of this.fields) {\n      mergedMaskSet = mergedMaskSet.add(fieldPath);\n    }\n    for (const fieldPath of extraFields) {\n      mergedMaskSet = mergedMaskSet.add(fieldPath);\n    }\n    return new FieldMask(mergedMaskSet.toArray());\n  }\n\n  /**\n   * Verifies that `fieldPath` is included by at least one field in this field\n   * mask.\n   *\n   * This is an O(n) operation, where `n` is the size of the field mask.\n   */\n  covers(fieldPath: FieldPath): boolean {\n    for (const fieldMaskPath of this.fields) {\n      if (fieldMaskPath.isPrefixOf(fieldPath)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isEqual(other: FieldMask): boolean {\n    return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * An error encountered while decoding base64 string.\n */\nexport class Base64DecodeError extends Error {\n  readonly name = 'Base64DecodeError';\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Base64DecodeError } from '../../util/base64_decode_error';\n\n/** Converts a Base64 encoded string to a binary string. */\nexport function decodeBase64(encoded: string): string {\n  try {\n    return atob(encoded);\n  } catch (e) {\n    // Check that `DOMException` is defined before using it to avoid\n    // \"ReferenceError: Property 'DOMException' doesn't exist\" in react-native.\n    // (https://github.com/firebase/firebase-js-sdk/issues/7115)\n    if (typeof DOMException !== 'undefined' && e instanceof DOMException) {\n      throw new Base64DecodeError('Invalid base64 string: ' + e);\n    } else {\n      throw e;\n    }\n  }\n}\n\n/** Converts a binary string to a Base64 encoded string. */\nexport function encodeBase64(raw: string): string {\n  return btoa(raw);\n}\n\n/** True if and only if the Base64 conversion functions are available. */\nexport function isBase64Available(): boolean {\n  return typeof atob !== 'undefined';\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBase64, encodeBase64 } from '../platform/base64';\n\nimport { primitiveComparator } from './misc';\n\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n * @internal\n */\nexport class ByteString {\n  static readonly EMPTY_BYTE_STRING = new ByteString('');\n\n  private constructor(private readonly binaryString: string) {}\n\n  static fromBase64String(base64: string): ByteString {\n    const binaryString = decodeBase64(base64);\n    return new ByteString(binaryString);\n  }\n\n  static fromUint8Array(array: Uint8Array): ByteString {\n    // TODO(indexing); Remove the copy of the byte string here as this method\n    // is frequently called during indexing.\n    const binaryString = binaryStringFromUint8Array(array);\n    return new ByteString(binaryString);\n  }\n\n  [Symbol.iterator](): Iterator<number> {\n    let i = 0;\n    return {\n      next: () => {\n        if (i < this.binaryString.length) {\n          return { value: this.binaryString.charCodeAt(i++), done: false };\n        } else {\n          return { value: undefined, done: true };\n        }\n      }\n    };\n  }\n\n  toBase64(): string {\n    return encodeBase64(this.binaryString);\n  }\n\n  toUint8Array(): Uint8Array {\n    return uint8ArrayFromBinaryString(this.binaryString);\n  }\n\n  approximateByteSize(): number {\n    return this.binaryString.length * 2;\n  }\n\n  compareTo(other: ByteString): number {\n    return primitiveComparator(this.binaryString, other.binaryString);\n  }\n\n  isEqual(other: ByteString): boolean {\n    return this.binaryString === other.binaryString;\n  }\n}\n\n/**\n * Helper function to convert an Uint8array to a binary string.\n */\nexport function binaryStringFromUint8Array(array: Uint8Array): string {\n  let binaryString = '';\n  for (let i = 0; i < array.length; ++i) {\n    binaryString += String.fromCharCode(array[i]);\n  }\n  return binaryString;\n}\n\n/**\n * Helper function to convert a binary string to an Uint8Array.\n */\nexport function uint8ArrayFromBinaryString(binaryString: string): Uint8Array {\n  const buffer = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    buffer[i] = binaryString.charCodeAt(i);\n  }\n  return buffer;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../protos/firestore_proto_api';\nimport { hardAssert } from '../util/assert';\nimport { ByteString } from '../util/byte_string';\n\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(\n  /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/\n);\n\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nexport function normalizeTimestamp(date: Timestamp): {\n  seconds: number;\n  nanos: number;\n} {\n  hardAssert(!!date, 0x986a, 'Cannot normalize null or undefined timestamp.');\n\n  // The json interface (for the browser) will return an iso timestamp string,\n  // while the proto js library (for node) will return a\n  // google.protobuf.Timestamp instance.\n  if (typeof date === 'string') {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n\n    // Parse the nanos right out of the string.\n    let nanos = 0;\n    const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n    hardAssert(!!fraction, 0xb5de, 'invalid timestamp', {\n      timestamp: date\n    });\n    if (fraction[1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      let nanoStr = fraction[1];\n      nanoStr = (nanoStr + '000000000').substr(0, 9);\n      nanos = Number(nanoStr);\n    }\n\n    // Parse the date to get the seconds.\n    const parsedDate = new Date(date);\n    const seconds = Math.floor(parsedDate.getTime() / 1000);\n\n    return { seconds, nanos };\n  } else {\n    // TODO(b/37282237): Use strings for Proto3 timestamps\n    // assert(!this.options.useProto3Json,\n    //   'The timestamp instance format requires Proto JS.');\n    const seconds = normalizeNumber(date.seconds);\n    const nanos = normalizeNumber(date.nanos);\n    return { seconds, nanos };\n  }\n}\n\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nexport function normalizeNumber(value: number | string | undefined): number {\n  // TODO(bjornick): Handle int64 greater than 53 bits.\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return Number(value);\n  } else {\n    return 0;\n  }\n}\n\n/** Converts the possible Proto types for Blobs into a ByteString. */\nexport function normalizeByteString(blob: string | Uint8Array): ByteString {\n  if (typeof blob === 'string') {\n    return ByteString.fromBase64String(blob);\n  } else {\n    return ByteString.fromUint8Array(blob);\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../lite-api/timestamp';\nimport {\n  Value as ProtoValue,\n  MapValue as ProtoMapValue\n} from '../protos/firestore_proto_api';\n\nimport { normalizeTimestamp } from './normalize';\n\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   transform. They can only exist in the local view of a document. Therefore\n *   they do not need to be parsed or serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\n\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\nconst TYPE_KEY = '__type__';\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\n\nexport function isServerTimestamp(value: ProtoValue | null): boolean {\n  const type = (value?.mapValue?.fields || {})[TYPE_KEY]?.stringValue;\n  return type === SERVER_TIMESTAMP_SENTINEL;\n}\n\n/**\n * Creates a new ServerTimestamp proto value (using the internal format).\n */\nexport function serverTimestamp(\n  localWriteTime: Timestamp,\n  previousValue: ProtoValue | null\n): ProtoValue {\n  const mapValue: ProtoMapValue = {\n    fields: {\n      [TYPE_KEY]: {\n        stringValue: SERVER_TIMESTAMP_SENTINEL\n      },\n      [LOCAL_WRITE_TIME_KEY]: {\n        timestampValue: {\n          seconds: localWriteTime.seconds,\n          nanos: localWriteTime.nanoseconds\n        }\n      }\n    }\n  };\n\n  // We should avoid storing deeply nested server timestamp map values\n  // because we never use the intermediate \"previous values\".\n  // For example:\n  // previous: 42L, add: t1, result: t1 -> 42L\n  // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\n  // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\n  // `getPreviousValue` recursively traverses server timestamps to find the\n  // least recent Value.\n  if (previousValue && isServerTimestamp(previousValue)) {\n    previousValue = getPreviousValue(previousValue);\n  }\n  if (previousValue) {\n    mapValue.fields![PREVIOUS_VALUE_KEY] = previousValue;\n  }\n\n  return { mapValue };\n}\n\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nexport function getPreviousValue(value: ProtoValue): ProtoValue | null {\n  const previousValue = value.mapValue!.fields![PREVIOUS_VALUE_KEY];\n\n  if (isServerTimestamp(previousValue)) {\n    return getPreviousValue(previousValue);\n  }\n  return previousValue;\n}\n\n/**\n * Returns the local time at which this timestamp was first set.\n */\nexport function getLocalWriteTime(value: ProtoValue): Timestamp {\n  const localWriteTime = normalizeTimestamp(\n    value.mapValue!.fields![LOCAL_WRITE_TIME_KEY].timestampValue!\n  );\n  return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n","import { FirebaseApp } from '@firebase/app';\n\nimport { ExperimentalLongPollingOptions } from '../api/long_polling_options';\nimport { Code, FirestoreError } from '../util/error';\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class DatabaseInfo {\n  /**\n   * Constructs a DatabaseInfo using the provided host, databaseId and\n   * persistenceKey.\n   *\n   * @param databaseId - The database to use.\n   * @param appId - The Firebase App Id.\n   * @param persistenceKey - A unique identifier for this Firestore's local\n   * storage (used in conjunction with the databaseId).\n   * @param host - The Firestore backend host to connect to.\n   * @param ssl - Whether to use SSL when connecting.\n   * @param forceLongPolling - Whether to use the forceLongPolling option\n   * when using WebChannel as the network transport.\n   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\n   * option when using WebChannel as the network transport.\n   * @param longPollingOptions - Options that configure long-polling.\n   * @param useFetchStreams - Whether to use the Fetch API instead of\n   * XMLHTTPRequest\n   */\n  constructor(\n    readonly databaseId: DatabaseId,\n    readonly appId: string,\n    readonly persistenceKey: string,\n    readonly host: string,\n    readonly ssl: boolean,\n    readonly forceLongPolling: boolean,\n    readonly autoDetectLongPolling: boolean,\n    readonly longPollingOptions: ExperimentalLongPollingOptions,\n    readonly useFetchStreams: boolean,\n    readonly isUsingEmulator: boolean,\n    readonly apiKey: string | undefined\n  ) {}\n}\n\n/** The default database name for a project. */\nexport const DEFAULT_DATABASE_NAME = '(default)';\n\n/**\n * Represents the database ID a Firestore client is associated with.\n * @internal\n */\nexport class DatabaseId {\n  readonly database: string;\n  constructor(readonly projectId: string, database?: string) {\n    this.database = database ? database : DEFAULT_DATABASE_NAME;\n  }\n\n  static empty(): DatabaseId {\n    return new DatabaseId('', '');\n  }\n\n  get isDefaultDatabase(): boolean {\n    return this.database === DEFAULT_DATABASE_NAME;\n  }\n\n  isEqual(other: {}): boolean {\n    return (\n      other instanceof DatabaseId &&\n      other.projectId === this.projectId &&\n      other.database === this.database\n    );\n  }\n}\n\nexport function databaseIdFromApp(\n  app: FirebaseApp,\n  database?: string\n): DatabaseId {\n  if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      '\"projectId\" not provided in firebase.initializeApp.'\n    );\n  }\n\n  return new DatabaseId(app.options.projectId!, database);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId } from '../core/database_info';\nimport {\n  ArrayValue,\n  LatLng,\n  MapValue,\n  Timestamp,\n  Value as ProtoValue,\n  Value\n} from '../protos/firestore_proto_api';\nimport { fail } from '../util/assert';\nimport {\n  arrayEquals,\n  compareUtf8Strings,\n  primitiveComparator\n} from '../util/misc';\nimport { forEach, objectSize } from '../util/obj';\nimport { isNegativeZero } from '../util/types';\n\nimport { DocumentKey } from './document_key';\nimport {\n  normalizeByteString,\n  normalizeNumber,\n  normalizeTimestamp\n} from './normalize';\nimport {\n  getLocalWriteTime,\n  getPreviousValue,\n  isServerTimestamp\n} from './server_timestamps';\nimport { TypeOrder } from './type_order';\n\nexport const TYPE_KEY = '__type__';\nconst MAX_VALUE_TYPE = '__max__';\nexport const MAX_VALUE: Value = {\n  mapValue: {\n    fields: {\n      '__type__': { stringValue: MAX_VALUE_TYPE }\n    }\n  }\n};\n\nexport const VECTOR_VALUE_SENTINEL = '__vector__';\nexport const VECTOR_MAP_VECTORS_KEY = 'value';\n\nexport const MIN_VALUE: Value = {\n  nullValue: 'NULL_VALUE'\n};\n\n/** Extracts the backend's type order for the provided value. */\nexport function typeOrder(value: Value): TypeOrder {\n  if ('nullValue' in value) {\n    return TypeOrder.NullValue;\n  } else if ('booleanValue' in value) {\n    return TypeOrder.BooleanValue;\n  } else if ('integerValue' in value || 'doubleValue' in value) {\n    return TypeOrder.NumberValue;\n  } else if ('timestampValue' in value) {\n    return TypeOrder.TimestampValue;\n  } else if ('stringValue' in value) {\n    return TypeOrder.StringValue;\n  } else if ('bytesValue' in value) {\n    return TypeOrder.BlobValue;\n  } else if ('referenceValue' in value) {\n    return TypeOrder.RefValue;\n  } else if ('geoPointValue' in value) {\n    return TypeOrder.GeoPointValue;\n  } else if ('arrayValue' in value) {\n    return TypeOrder.ArrayValue;\n  } else if ('mapValue' in value) {\n    if (isServerTimestamp(value)) {\n      return TypeOrder.ServerTimestampValue;\n    } else if (isMaxValue(value)) {\n      return TypeOrder.MaxValue;\n    } else if (isVectorValue(value)) {\n      return TypeOrder.VectorValue;\n    }\n    return TypeOrder.ObjectValue;\n  } else {\n    return fail(0x6e87, 'Invalid value type', { value });\n  }\n}\n\n/** Tests `left` and `right` for equality based on the backend semantics. */\nexport function valueEquals(left: Value, right: Value): boolean {\n  if (left === right) {\n    return true;\n  }\n\n  const leftType = typeOrder(left);\n  const rightType = typeOrder(right);\n  if (leftType !== rightType) {\n    return false;\n  }\n\n  switch (leftType) {\n    case TypeOrder.NullValue:\n      return true;\n    case TypeOrder.BooleanValue:\n      return left.booleanValue === right.booleanValue;\n    case TypeOrder.ServerTimestampValue:\n      return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n    case TypeOrder.TimestampValue:\n      return timestampEquals(left, right);\n    case TypeOrder.StringValue:\n      return left.stringValue === right.stringValue;\n    case TypeOrder.BlobValue:\n      return blobEquals(left, right);\n    case TypeOrder.RefValue:\n      return left.referenceValue === right.referenceValue;\n    case TypeOrder.GeoPointValue:\n      return geoPointEquals(left, right);\n    case TypeOrder.NumberValue:\n      return numberEquals(left, right);\n    case TypeOrder.ArrayValue:\n      return arrayEquals(\n        left.arrayValue!.values || [],\n        right.arrayValue!.values || [],\n        valueEquals\n      );\n    case TypeOrder.VectorValue:\n    case TypeOrder.ObjectValue:\n      return objectEquals(left, right);\n    case TypeOrder.MaxValue:\n      return true;\n    default:\n      return fail(0xcbf8, 'Unexpected value type', { left });\n  }\n}\n\nfunction timestampEquals(left: Value, right: Value): boolean {\n  if (\n    typeof left.timestampValue === 'string' &&\n    typeof right.timestampValue === 'string' &&\n    left.timestampValue.length === right.timestampValue.length\n  ) {\n    // Use string equality for ISO 8601 timestamps\n    return left.timestampValue === right.timestampValue;\n  }\n\n  const leftTimestamp = normalizeTimestamp(left.timestampValue!);\n  const rightTimestamp = normalizeTimestamp(right.timestampValue!);\n  return (\n    leftTimestamp.seconds === rightTimestamp.seconds &&\n    leftTimestamp.nanos === rightTimestamp.nanos\n  );\n}\n\nfunction geoPointEquals(left: Value, right: Value): boolean {\n  return (\n    normalizeNumber(left.geoPointValue!.latitude) ===\n      normalizeNumber(right.geoPointValue!.latitude) &&\n    normalizeNumber(left.geoPointValue!.longitude) ===\n      normalizeNumber(right.geoPointValue!.longitude)\n  );\n}\n\nfunction blobEquals(left: Value, right: Value): boolean {\n  return normalizeByteString(left.bytesValue!).isEqual(\n    normalizeByteString(right.bytesValue!)\n  );\n}\n\nexport function numberEquals(left: Value, right: Value): boolean {\n  if ('integerValue' in left && 'integerValue' in right) {\n    return (\n      normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue)\n    );\n  } else if ('doubleValue' in left && 'doubleValue' in right) {\n    const n1 = normalizeNumber(left.doubleValue!);\n    const n2 = normalizeNumber(right.doubleValue!);\n\n    if (n1 === n2) {\n      return isNegativeZero(n1) === isNegativeZero(n2);\n    } else {\n      return isNaN(n1) && isNaN(n2);\n    }\n  }\n\n  return false;\n}\n\nfunction objectEquals(left: Value, right: Value): boolean {\n  const leftMap = left.mapValue!.fields || {};\n  const rightMap = right.mapValue!.fields || {};\n\n  if (objectSize(leftMap) !== objectSize(rightMap)) {\n    return false;\n  }\n\n  for (const key in leftMap) {\n    if (leftMap.hasOwnProperty(key)) {\n      if (\n        rightMap[key] === undefined ||\n        !valueEquals(leftMap[key], rightMap[key])\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/** Returns true if the ArrayValue contains the specified element. */\nexport function arrayValueContains(\n  haystack: ArrayValue,\n  needle: Value\n): boolean {\n  return (\n    (haystack.values || []).find(v => valueEquals(v, needle)) !== undefined\n  );\n}\n\nexport function valueCompare(left: Value, right: Value): number {\n  if (left === right) {\n    return 0;\n  }\n\n  const leftType = typeOrder(left);\n  const rightType = typeOrder(right);\n\n  if (leftType !== rightType) {\n    return primitiveComparator(leftType, rightType);\n  }\n\n  switch (leftType) {\n    case TypeOrder.NullValue:\n    case TypeOrder.MaxValue:\n      return 0;\n    case TypeOrder.BooleanValue:\n      return primitiveComparator(left.booleanValue!, right.booleanValue!);\n    case TypeOrder.NumberValue:\n      return compareNumbers(left, right);\n    case TypeOrder.TimestampValue:\n      return compareTimestamps(left.timestampValue!, right.timestampValue!);\n    case TypeOrder.ServerTimestampValue:\n      return compareTimestamps(\n        getLocalWriteTime(left),\n        getLocalWriteTime(right)\n      );\n    case TypeOrder.StringValue:\n      return compareUtf8Strings(left.stringValue!, right.stringValue!);\n    case TypeOrder.BlobValue:\n      return compareBlobs(left.bytesValue!, right.bytesValue!);\n    case TypeOrder.RefValue:\n      return compareReferences(left.referenceValue!, right.referenceValue!);\n    case TypeOrder.GeoPointValue:\n      return compareGeoPoints(left.geoPointValue!, right.geoPointValue!);\n    case TypeOrder.ArrayValue:\n      return compareArrays(left.arrayValue!, right.arrayValue!);\n    case TypeOrder.VectorValue:\n      return compareVectors(left.mapValue!, right.mapValue!);\n    case TypeOrder.ObjectValue:\n      return compareMaps(left.mapValue!, right.mapValue!);\n    default:\n      throw fail(0x5ae0, 'Invalid value type', { leftType });\n  }\n}\n\nfunction compareNumbers(left: Value, right: Value): number {\n  const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n  const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n\n  if (leftNumber < rightNumber) {\n    return -1;\n  } else if (leftNumber > rightNumber) {\n    return 1;\n  } else if (leftNumber === rightNumber) {\n    return 0;\n  } else {\n    // one or both are NaN.\n    if (isNaN(leftNumber)) {\n      return isNaN(rightNumber) ? 0 : -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\nfunction compareTimestamps(left: Timestamp, right: Timestamp): number {\n  if (\n    typeof left === 'string' &&\n    typeof right === 'string' &&\n    left.length === right.length\n  ) {\n    return primitiveComparator(left, right);\n  }\n\n  const leftTimestamp = normalizeTimestamp(left);\n  const rightTimestamp = normalizeTimestamp(right);\n\n  const comparison = primitiveComparator(\n    leftTimestamp.seconds,\n    rightTimestamp.seconds\n  );\n  if (comparison !== 0) {\n    return comparison;\n  }\n  return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\n\nfunction compareReferences(leftPath: string, rightPath: string): number {\n  const leftSegments = leftPath.split('/');\n  const rightSegments = rightPath.split('/');\n  for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\n    const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n    if (comparison !== 0) {\n      return comparison;\n    }\n  }\n  return primitiveComparator(leftSegments.length, rightSegments.length);\n}\n\nfunction compareGeoPoints(left: LatLng, right: LatLng): number {\n  const comparison = primitiveComparator(\n    normalizeNumber(left.latitude),\n    normalizeNumber(right.latitude)\n  );\n  if (comparison !== 0) {\n    return comparison;\n  }\n  return primitiveComparator(\n    normalizeNumber(left.longitude),\n    normalizeNumber(right.longitude)\n  );\n}\n\nfunction compareBlobs(\n  left: string | Uint8Array,\n  right: string | Uint8Array\n): number {\n  const leftBytes = normalizeByteString(left);\n  const rightBytes = normalizeByteString(right);\n  return leftBytes.compareTo(rightBytes);\n}\n\nfunction compareArrays(left: ArrayValue, right: ArrayValue): number {\n  const leftArray = left.values || [];\n  const rightArray = right.values || [];\n\n  for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\n    const compare = valueCompare(leftArray[i], rightArray[i]);\n    if (compare) {\n      return compare;\n    }\n  }\n  return primitiveComparator(leftArray.length, rightArray.length);\n}\n\nfunction compareVectors(left: MapValue, right: MapValue): number {\n  const leftMap = left.fields || {};\n  const rightMap = right.fields || {};\n\n  // The vector is a map, but only vector value is compared.\n  const leftArrayValue = leftMap[VECTOR_MAP_VECTORS_KEY]?.arrayValue;\n  const rightArrayValue = rightMap[VECTOR_MAP_VECTORS_KEY]?.arrayValue;\n\n  const lengthCompare = primitiveComparator(\n    leftArrayValue?.values?.length || 0,\n    rightArrayValue?.values?.length || 0\n  );\n  if (lengthCompare !== 0) {\n    return lengthCompare;\n  }\n\n  return compareArrays(leftArrayValue!, rightArrayValue!);\n}\n\nfunction compareMaps(left: MapValue, right: MapValue): number {\n  if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\n    return 0;\n  } else if (left === MAX_VALUE.mapValue) {\n    return 1;\n  } else if (right === MAX_VALUE.mapValue) {\n    return -1;\n  }\n\n  const leftMap = left.fields || {};\n  const leftKeys = Object.keys(leftMap);\n  const rightMap = right.fields || {};\n  const rightKeys = Object.keys(rightMap);\n\n  // Even though MapValues are likely sorted correctly based on their insertion\n  // order (e.g. when received from the backend), local modifications can bring\n  // elements out of order. We need to re-sort the elements to ensure that\n  // canonical IDs are independent of insertion order.\n  leftKeys.sort();\n  rightKeys.sort();\n\n  for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\n    const keyCompare = compareUtf8Strings(leftKeys[i], rightKeys[i]);\n    if (keyCompare !== 0) {\n      return keyCompare;\n    }\n    const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n    if (compare !== 0) {\n      return compare;\n    }\n  }\n\n  return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n\n/**\n * Generates the canonical ID for the provided field value (as used in Target\n * serialization).\n */\nexport function canonicalId(value: Value): string {\n  return canonifyValue(value);\n}\n\nfunction canonifyValue(value: Value): string {\n  if ('nullValue' in value) {\n    return 'null';\n  } else if ('booleanValue' in value) {\n    return '' + value.booleanValue!;\n  } else if ('integerValue' in value) {\n    return '' + value.integerValue!;\n  } else if ('doubleValue' in value) {\n    return '' + value.doubleValue!;\n  } else if ('timestampValue' in value) {\n    return canonifyTimestamp(value.timestampValue!);\n  } else if ('stringValue' in value) {\n    return value.stringValue!;\n  } else if ('bytesValue' in value) {\n    return canonifyByteString(value.bytesValue!);\n  } else if ('referenceValue' in value) {\n    return canonifyReference(value.referenceValue!);\n  } else if ('geoPointValue' in value) {\n    return canonifyGeoPoint(value.geoPointValue!);\n  } else if ('arrayValue' in value) {\n    return canonifyArray(value.arrayValue!);\n  } else if ('mapValue' in value) {\n    return canonifyMap(value.mapValue!);\n  } else {\n    return fail(0xee4d, 'Invalid value type', { value });\n  }\n}\n\nfunction canonifyByteString(byteString: string | Uint8Array): string {\n  return normalizeByteString(byteString).toBase64();\n}\n\nfunction canonifyTimestamp(timestamp: Timestamp): string {\n  const normalizedTimestamp = normalizeTimestamp(timestamp);\n  return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\n}\n\nfunction canonifyGeoPoint(geoPoint: LatLng): string {\n  return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\n\nfunction canonifyReference(referenceValue: string): string {\n  return DocumentKey.fromName(referenceValue).toString();\n}\n\nfunction canonifyMap(mapValue: MapValue): string {\n  // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n  // matching canonical IDs for identical maps, we need to sort the keys.\n  const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n\n  let result = '{';\n  let first = true;\n  for (const key of sortedKeys) {\n    if (!first) {\n      result += ',';\n    } else {\n      first = false;\n    }\n    result += `${key}:${canonifyValue(mapValue.fields![key])}`;\n  }\n  return result + '}';\n}\n\nfunction canonifyArray(arrayValue: ArrayValue): string {\n  let result = '[';\n  let first = true;\n  for (const value of arrayValue.values || []) {\n    if (!first) {\n      result += ',';\n    } else {\n      first = false;\n    }\n    result += canonifyValue(value);\n  }\n  return result + ']';\n}\n\n/**\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\n * value.\n *\n * The memory size takes into account only the actual user data as it resides\n * in memory and ignores object overhead.\n */\nexport function estimateByteSize(value: Value): number {\n  switch (typeOrder(value)) {\n    case TypeOrder.NullValue:\n      return 4;\n    case TypeOrder.BooleanValue:\n      return 4;\n    case TypeOrder.NumberValue:\n      return 8;\n    case TypeOrder.TimestampValue:\n      // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\n      return 16;\n    case TypeOrder.ServerTimestampValue:\n      const previousValue = getPreviousValue(value);\n      return previousValue ? 16 + estimateByteSize(previousValue) : 16;\n    case TypeOrder.StringValue:\n      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\n      // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\n      // integer values\"\n      return value.stringValue!.length * 2;\n    case TypeOrder.BlobValue:\n      return normalizeByteString(value.bytesValue!).approximateByteSize();\n    case TypeOrder.RefValue:\n      return value.referenceValue!.length;\n    case TypeOrder.GeoPointValue:\n      // GeoPoints are made up of two distinct numbers (latitude + longitude)\n      return 16;\n    case TypeOrder.ArrayValue:\n      return estimateArrayByteSize(value.arrayValue!);\n    case TypeOrder.VectorValue:\n    case TypeOrder.ObjectValue:\n      return estimateMapByteSize(value.mapValue!);\n    default:\n      throw fail(0x34ae, 'Invalid value type', { value });\n  }\n}\n\nfunction estimateMapByteSize(mapValue: MapValue): number {\n  let size = 0;\n  forEach(mapValue.fields, (key, val) => {\n    size += key.length + estimateByteSize(val);\n  });\n  return size;\n}\n\nfunction estimateArrayByteSize(arrayValue: ArrayValue): number {\n  return (arrayValue.values || []).reduce(\n    (previousSize, value) => previousSize + estimateByteSize(value),\n    0\n  );\n}\n\n/** Returns a reference value for the provided database and key. */\nexport function refValue(databaseId: DatabaseId, key: DocumentKey): Value {\n  return {\n    referenceValue: `projects/${databaseId.projectId}/databases/${\n      databaseId.database\n    }/documents/${key.path.canonicalString()}`\n  };\n}\n\n/** Returns true if `value` is an IntegerValue . */\nexport function isInteger(\n  value?: Value | null\n): value is { integerValue: string | number } {\n  return !!value && 'integerValue' in value;\n}\n\n/** Returns true if `value` is a DoubleValue. */\nexport function isDouble(\n  value?: Value | null\n): value is { doubleValue: string | number } {\n  return !!value && 'doubleValue' in value;\n}\n\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\nexport function isNumber(value?: Value | null): boolean {\n  return isInteger(value) || isDouble(value);\n}\n\n/** Returns true if `value` is an ArrayValue. */\nexport function isArray(\n  value?: Value | null\n): value is { arrayValue: ArrayValue } {\n  return !!value && 'arrayValue' in value;\n}\n\n/** Returns true if `value` is a ReferenceValue. */\nexport function isReferenceValue(\n  value?: Value | null\n): value is { referenceValue: string } {\n  return !!value && 'referenceValue' in value;\n}\n\n/** Returns true if `value` is a NullValue. */\nexport function isNullValue(\n  value?: Value | null\n): value is { nullValue: 'NULL_VALUE' } {\n  return !!value && 'nullValue' in value;\n}\n\n/** Returns true if `value` is NaN. */\nexport function isNanValue(\n  value?: Value | null\n): value is { doubleValue: 'NaN' | number } {\n  return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\n}\n\n/** Returns true if `value` is a MapValue. */\nexport function isMapValue(\n  value?: Value | null\n): value is { mapValue: MapValue } {\n  return !!value && 'mapValue' in value;\n}\n\n/** Returns true if `value` is a VetorValue. */\nexport function isVectorValue(value: ProtoValue | null): boolean {\n  const type = (value?.mapValue?.fields || {})[TYPE_KEY]?.stringValue;\n  return type === VECTOR_VALUE_SENTINEL;\n}\n\n/** Creates a deep copy of `source`. */\nexport function deepClone(source: Value): Value {\n  if (source.geoPointValue) {\n    return { geoPointValue: { ...source.geoPointValue } };\n  } else if (\n    source.timestampValue &&\n    typeof source.timestampValue === 'object'\n  ) {\n    return { timestampValue: { ...source.timestampValue } };\n  } else if (source.mapValue) {\n    const target: Value = { mapValue: { fields: {} } };\n    forEach(\n      source.mapValue.fields,\n      (key, val) => (target.mapValue!.fields![key] = deepClone(val))\n    );\n    return target;\n  } else if (source.arrayValue) {\n    const target: Value = { arrayValue: { values: [] } };\n    for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\n      target.arrayValue!.values![i] = deepClone(source.arrayValue.values![i]);\n    }\n    return target;\n  } else {\n    return { ...source };\n  }\n}\n\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\nexport function isMaxValue(value: Value): boolean {\n  return (\n    (((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\n    MAX_VALUE_TYPE\n  );\n}\n\nexport const MIN_VECTOR_VALUE = {\n  mapValue: {\n    fields: {\n      [TYPE_KEY]: { stringValue: VECTOR_VALUE_SENTINEL },\n      [VECTOR_MAP_VECTORS_KEY]: {\n        arrayValue: {}\n      }\n    }\n  }\n};\n\n/** Returns the lowest value for the given value type (inclusive). */\nexport function valuesGetLowerBound(value: Value): Value {\n  if ('nullValue' in value) {\n    return MIN_VALUE;\n  } else if ('booleanValue' in value) {\n    return { booleanValue: false };\n  } else if ('integerValue' in value || 'doubleValue' in value) {\n    return { doubleValue: NaN };\n  } else if ('timestampValue' in value) {\n    return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n  } else if ('stringValue' in value) {\n    return { stringValue: '' };\n  } else if ('bytesValue' in value) {\n    return { bytesValue: '' };\n  } else if ('referenceValue' in value) {\n    return refValue(DatabaseId.empty(), DocumentKey.empty());\n  } else if ('geoPointValue' in value) {\n    return { geoPointValue: { latitude: -90, longitude: -180 } };\n  } else if ('arrayValue' in value) {\n    return { arrayValue: {} };\n  } else if ('mapValue' in value) {\n    if (isVectorValue(value)) {\n      return MIN_VECTOR_VALUE;\n    }\n    return { mapValue: {} };\n  } else {\n    return fail(0x8c66, 'Invalid value type', { value });\n  }\n}\n\n/** Returns the largest value for the given value type (exclusive). */\nexport function valuesGetUpperBound(value: Value): Value {\n  if ('nullValue' in value) {\n    return { booleanValue: false };\n  } else if ('booleanValue' in value) {\n    return { doubleValue: NaN };\n  } else if ('integerValue' in value || 'doubleValue' in value) {\n    return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n  } else if ('timestampValue' in value) {\n    return { stringValue: '' };\n  } else if ('stringValue' in value) {\n    return { bytesValue: '' };\n  } else if ('bytesValue' in value) {\n    return refValue(DatabaseId.empty(), DocumentKey.empty());\n  } else if ('referenceValue' in value) {\n    return { geoPointValue: { latitude: -90, longitude: -180 } };\n  } else if ('geoPointValue' in value) {\n    return { arrayValue: {} };\n  } else if ('arrayValue' in value) {\n    return MIN_VECTOR_VALUE;\n  } else if ('mapValue' in value) {\n    if (isVectorValue(value)) {\n      return { mapValue: {} };\n    }\n    return MAX_VALUE;\n  } else {\n    return fail(0xf207, 'Invalid value type', { value });\n  }\n}\n\nexport function lowerBoundCompare(\n  left: { value: Value; inclusive: boolean },\n  right: { value: Value; inclusive: boolean }\n): number {\n  const cmp = valueCompare(left.value, right.value);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  if (left.inclusive && !right.inclusive) {\n    return -1;\n  } else if (!left.inclusive && right.inclusive) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexport function upperBoundCompare(\n  left: { value: Value; inclusive: boolean },\n  right: { value: Value; inclusive: boolean }\n): number {\n  const cmp = valueCompare(left.value, right.value);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  if (left.inclusive && !right.inclusive) {\n    return 1;\n  } else if (!left.inclusive && right.inclusive) {\n    return -1;\n  }\n\n  return 0;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  MapValue as ProtoMapValue,\n  Value as ProtoValue\n} from '../protos/firestore_proto_api';\nimport { debugAssert } from '../util/assert';\nimport { forEach } from '../util/obj';\n\nimport { FieldMask } from './field_mask';\nimport { FieldPath } from './path';\nimport { isServerTimestamp } from './server_timestamps';\nimport { deepClone, isMapValue, valueEquals } from './values';\n\nexport interface JsonObject<T> {\n  [name: string]: T;\n}\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nexport class ObjectValue {\n  constructor(readonly value: { mapValue: ProtoMapValue }) {\n    debugAssert(\n      !isServerTimestamp(value),\n      'ServerTimestamps should be converted to ServerTimestampValue'\n    );\n  }\n\n  static empty(): ObjectValue {\n    return new ObjectValue({ mapValue: {} });\n  }\n\n  /**\n   * Returns the value at the given path or null.\n   *\n   * @param path - the path to search\n   * @returns The value at the path or null if the path is not set.\n   */\n  field(path: FieldPath): ProtoValue | null {\n    if (path.isEmpty()) {\n      return this.value;\n    } else {\n      let currentLevel: ProtoValue = this.value;\n      for (let i = 0; i < path.length - 1; ++i) {\n        currentLevel = (currentLevel.mapValue!.fields || {})[path.get(i)];\n        if (!isMapValue(currentLevel)) {\n          return null;\n        }\n      }\n      currentLevel = (currentLevel.mapValue!.fields! || {})[path.lastSegment()];\n      return currentLevel || null;\n    }\n  }\n\n  /**\n   * Sets the field to the provided value.\n   *\n   * @param path - The field path to set.\n   * @param value - The value to set.\n   */\n  set(path: FieldPath, value: ProtoValue): void {\n    debugAssert(\n      !path.isEmpty(),\n      'Cannot set field for empty path on ObjectValue'\n    );\n    const fieldsMap = this.getFieldsMap(path.popLast());\n    fieldsMap[path.lastSegment()] = deepClone(value);\n  }\n\n  /**\n   * Sets the provided fields to the provided values.\n   *\n   * @param data - A map of fields to values (or null for deletes).\n   */\n  setAll(data: Map<FieldPath, ProtoValue | null>): void {\n    let parent = FieldPath.emptyPath();\n\n    let upserts: { [key: string]: ProtoValue } = {};\n    let deletes: string[] = [];\n\n    data.forEach((value, path) => {\n      if (!parent.isImmediateParentOf(path)) {\n        // Insert the accumulated changes at this parent location\n        const fieldsMap = this.getFieldsMap(parent);\n        this.applyChanges(fieldsMap, upserts, deletes);\n        upserts = {};\n        deletes = [];\n        parent = path.popLast();\n      }\n\n      if (value) {\n        upserts[path.lastSegment()] = deepClone(value);\n      } else {\n        deletes.push(path.lastSegment());\n      }\n    });\n\n    const fieldsMap = this.getFieldsMap(parent);\n    this.applyChanges(fieldsMap, upserts, deletes);\n  }\n\n  /**\n   * Removes the field at the specified path. If there is no field at the\n   * specified path, nothing is changed.\n   *\n   * @param path - The field path to remove.\n   */\n  delete(path: FieldPath): void {\n    debugAssert(\n      !path.isEmpty(),\n      'Cannot delete field for empty path on ObjectValue'\n    );\n    const nestedValue = this.field(path.popLast());\n    if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\n      delete nestedValue.mapValue.fields[path.lastSegment()];\n    }\n  }\n\n  isEqual(other: ObjectValue): boolean {\n    return valueEquals(this.value, other.value);\n  }\n\n  /**\n   * Returns the map that contains the leaf element of `path`. If the parent\n   * entry does not yet exist, or if it is not a map, a new map will be created.\n   */\n  private getFieldsMap(path: FieldPath): Record<string, ProtoValue> {\n    let current = this.value;\n\n    if (!current.mapValue!.fields) {\n      current.mapValue = { fields: {} };\n    }\n\n    for (let i = 0; i < path.length; ++i) {\n      let next = current.mapValue!.fields![path.get(i)];\n      if (!isMapValue(next) || !next.mapValue.fields) {\n        next = { mapValue: { fields: {} } };\n        current.mapValue!.fields![path.get(i)] = next;\n      }\n      current = next as { mapValue: ProtoMapValue };\n    }\n\n    return current.mapValue!.fields!;\n  }\n\n  /**\n   * Modifies `fieldsMap` by adding, replacing or deleting the specified\n   * entries.\n   */\n  private applyChanges(\n    fieldsMap: Record<string, ProtoValue>,\n    inserts: { [key: string]: ProtoValue },\n    deletes: string[]\n  ): void {\n    forEach(inserts, (key, val) => (fieldsMap[key] = val));\n    for (const field of deletes) {\n      delete fieldsMap[field];\n    }\n  }\n\n  clone(): ObjectValue {\n    return new ObjectValue(\n      deepClone(this.value) as { mapValue: ProtoMapValue }\n    );\n  }\n}\n\n/**\n * Returns a FieldMask built from all fields in a MapValue.\n */\nexport function extractFieldMask(value: ProtoMapValue): FieldMask {\n  const fields: FieldPath[] = [];\n  forEach(value!.fields, (key, value) => {\n    const currentPath = new FieldPath([key]);\n    if (isMapValue(value)) {\n      const nestedMask = extractFieldMask(value.mapValue!);\n      const nestedFields = nestedMask.fields;\n      if (nestedFields.length === 0) {\n        // Preserve the empty map by adding it to the FieldMask.\n        fields.push(currentPath);\n      } else {\n        // For nested and non-empty ObjectValues, add the FieldPath of the\n        // leaf nodes.\n        for (const nestedPath of nestedFields) {\n          fields.push(currentPath.child(nestedPath));\n        }\n      }\n    } else {\n      // For nested and non-empty ObjectValues, add the FieldPath of the leaf\n      // nodes.\n      fields.push(currentPath);\n    }\n  });\n  return new FieldMask(fields);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { debugAssert, fail } from '../util/assert';\n\nimport { DocumentKey } from './document_key';\nimport { ObjectValue } from './object_value';\nimport { FieldPath } from './path';\nimport { valueCompare } from './values';\n\n/**\n * Whether the document represents an existing document, a document that is\n * known to exist or a document whose state or existence is unknown.\n */\nconst enum DocumentType {\n  /**\n   * Represents the initial state of a MutableDocument when only the document\n   * key is known. Invalid documents transition to other states as mutations are\n   * applied. If a document remains invalid after applying mutations, it should\n   * be discarded.\n   *\n   * Invalid documents can have neither local nor committed mutations.\n   */\n  INVALID,\n  /**\n   * Represents a document in Firestore with a key, version, data and whether\n   * the data has local mutations applied to it.\n   *\n   * Found documents can be synced or have or committed mutations applied.\n   */\n  FOUND_DOCUMENT,\n  /**\n   * Represents that no documents exists for the key at the given version.\n   *\n   * Documents that are deleted based on a local mutation do not raise snapshots\n   * with `hasPendingWrites`. As such, deleted documents never have\n   * `HAS_LOCAL_MUTATIONS` set. Once a delete is committed, we store them with\n   * `HAS_COMMITTED_MUTATIONS` until we received the delete from the Watch\n   * stream.\n   */\n  NO_DOCUMENT,\n  /**\n   * Represents an existing document whose data is unknown (e.g. a document that\n   * was updated without a known base document).\n   *\n   * An unknown document always has `HAS_COMMITTED_MUTATIONS` set, since unknown\n   * documents can only be generated by applying a patch mutation from a write\n   * acknowledgement.\n   */\n  UNKNOWN_DOCUMENT\n}\n\n/** Describes whether a document has latency-compensated edits applied. */\nconst enum DocumentState {\n  /** No mutations applied. Document was sent to us by Watch. */\n  SYNCED,\n  /**\n   * Local mutations applied via the mutation queue. Document is potentially\n   * inconsistent.\n   */\n  HAS_LOCAL_MUTATIONS,\n  /**\n   * Mutations applied based on a write acknowledgment. Document is potentially\n   * inconsistent.\n   */\n  HAS_COMMITTED_MUTATIONS\n}\n\n/**\n * Represents a document in Firestore with a key, version, data and whether the\n * data has local mutations applied to it.\n */\nexport interface Document {\n  /** The key for this document */\n  readonly key: DocumentKey;\n\n  /**\n   * The version of this document if it exists or a version at which this\n   * document was guaranteed to not exist.\n   */\n  readonly version: SnapshotVersion;\n\n  /**\n   * The timestamp at which this document was read from the remote server. Uses\n   * `SnapshotVersion.min()` for documents created by the user.\n   */\n  readonly readTime: SnapshotVersion;\n\n  /**\n   * The timestamp at which the document was created. This value increases\n   * monotonically when a document is deleted then recreated. It can also be\n   * compared to `createTime` of other documents and the `readTime` of a query.\n   */\n  readonly createTime: SnapshotVersion;\n\n  /** The underlying data of this document or an empty value if no data exists. */\n  readonly data: ObjectValue;\n\n  /** Returns whether local mutations were applied via the mutation queue. */\n  readonly hasLocalMutations: boolean;\n\n  /** Returns whether mutations were applied based on a write acknowledgment. */\n  readonly hasCommittedMutations: boolean;\n\n  /**\n   * Whether this document had a local mutation applied that has not yet been\n   * acknowledged by Watch.\n   */\n  readonly hasPendingWrites: boolean;\n\n  /**\n   * Returns whether this document is valid (i.e. it is an entry in the\n   * RemoteDocumentCache, was created by a mutation or read from the backend).\n   */\n  isValidDocument(): boolean;\n\n  /**\n   * Returns whether the document exists and its data is known at the current\n   * version.\n   */\n  isFoundDocument(): boolean;\n\n  /**\n   * Returns whether the document is known to not exist at the current version.\n   */\n  isNoDocument(): boolean;\n\n  /**\n   * Returns whether the document exists and its data is unknown at the current\n   * version.\n   */\n  isUnknownDocument(): boolean;\n\n  isEqual(other: Document | null | undefined): boolean;\n\n  /** Creates a mutable copy of this document. */\n  mutableCopy(): MutableDocument;\n\n  toString(): string;\n}\n\n/**\n * Represents a document in Firestore with a key, version, data and whether it\n * has local mutations applied to it.\n *\n * Documents can transition between states via `convertToFoundDocument()`,\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\n * not transition to one of these states even after all mutations have been\n * applied, `isValidDocument()` returns false and the document should be removed\n * from all views.\n */\nexport class MutableDocument implements Document {\n  private constructor(\n    readonly key: DocumentKey,\n    private documentType: DocumentType,\n    public version: SnapshotVersion,\n    public readTime: SnapshotVersion,\n    public createTime: SnapshotVersion,\n    public data: ObjectValue,\n    private documentState: DocumentState\n  ) {}\n\n  /**\n   * Creates a document with no known version or data, but which can serve as\n   * base document for mutations.\n   */\n  static newInvalidDocument(documentKey: DocumentKey): MutableDocument {\n    return new MutableDocument(\n      documentKey,\n      DocumentType.INVALID,\n      /* version */ SnapshotVersion.min(),\n      /* readTime */ SnapshotVersion.min(),\n      /* createTime */ SnapshotVersion.min(),\n      ObjectValue.empty(),\n      DocumentState.SYNCED\n    );\n  }\n\n  /**\n   * Creates a new document that is known to exist with the given data at the\n   * given version.\n   */\n  static newFoundDocument(\n    documentKey: DocumentKey,\n    version: SnapshotVersion,\n    createTime: SnapshotVersion,\n    value: ObjectValue\n  ): MutableDocument {\n    return new MutableDocument(\n      documentKey,\n      DocumentType.FOUND_DOCUMENT,\n      /* version */ version,\n      /* readTime */ SnapshotVersion.min(),\n      /* createTime */ createTime,\n      value,\n      DocumentState.SYNCED\n    );\n  }\n\n  /** Creates a new document that is known to not exist at the given version. */\n  static newNoDocument(\n    documentKey: DocumentKey,\n    version: SnapshotVersion\n  ): MutableDocument {\n    return new MutableDocument(\n      documentKey,\n      DocumentType.NO_DOCUMENT,\n      /* version */ version,\n      /* readTime */ SnapshotVersion.min(),\n      /* createTime */ SnapshotVersion.min(),\n      ObjectValue.empty(),\n      DocumentState.SYNCED\n    );\n  }\n\n  /**\n   * Creates a new document that is known to exist at the given version but\n   * whose data is not known (e.g. a document that was updated without a known\n   * base document).\n   */\n  static newUnknownDocument(\n    documentKey: DocumentKey,\n    version: SnapshotVersion\n  ): MutableDocument {\n    return new MutableDocument(\n      documentKey,\n      DocumentType.UNKNOWN_DOCUMENT,\n      /* version */ version,\n      /* readTime */ SnapshotVersion.min(),\n      /* createTime */ SnapshotVersion.min(),\n      ObjectValue.empty(),\n      DocumentState.HAS_COMMITTED_MUTATIONS\n    );\n  }\n\n  /**\n   * Changes the document type to indicate that it exists and that its version\n   * and data are known.\n   */\n  convertToFoundDocument(\n    version: SnapshotVersion,\n    value: ObjectValue\n  ): MutableDocument {\n    // If a document is switching state from being an invalid or deleted\n    // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n    // update from Watch or due to applying a local set mutation on top\n    // of a deleted document, our best guess about its createTime would be the\n    // version at which the document transitioned to a FOUND_DOCUMENT.\n    if (\n      this.createTime.isEqual(SnapshotVersion.min()) &&\n      (this.documentType === DocumentType.NO_DOCUMENT ||\n        this.documentType === DocumentType.INVALID)\n    ) {\n      this.createTime = version;\n    }\n    this.version = version;\n    this.documentType = DocumentType.FOUND_DOCUMENT;\n    this.data = value;\n    this.documentState = DocumentState.SYNCED;\n    return this;\n  }\n\n  /**\n   * Changes the document type to indicate that it doesn't exist at the given\n   * version.\n   */\n  convertToNoDocument(version: SnapshotVersion): MutableDocument {\n    this.version = version;\n    this.documentType = DocumentType.NO_DOCUMENT;\n    this.data = ObjectValue.empty();\n    this.documentState = DocumentState.SYNCED;\n    return this;\n  }\n\n  /**\n   * Changes the document type to indicate that it exists at a given version but\n   * that its data is not known (e.g. a document that was updated without a known\n   * base document).\n   */\n  convertToUnknownDocument(version: SnapshotVersion): MutableDocument {\n    this.version = version;\n    this.documentType = DocumentType.UNKNOWN_DOCUMENT;\n    this.data = ObjectValue.empty();\n    this.documentState = DocumentState.HAS_COMMITTED_MUTATIONS;\n    return this;\n  }\n\n  setHasCommittedMutations(): MutableDocument {\n    debugAssert(\n      this.isValidDocument(),\n      'Invalid documents cannot have committed mutations'\n    );\n    this.documentState = DocumentState.HAS_COMMITTED_MUTATIONS;\n    return this;\n  }\n\n  setHasLocalMutations(): MutableDocument {\n    this.documentState = DocumentState.HAS_LOCAL_MUTATIONS;\n    this.version = SnapshotVersion.min();\n    return this;\n  }\n\n  setReadTime(readTime: SnapshotVersion): MutableDocument {\n    this.readTime = readTime;\n    return this;\n  }\n\n  get hasLocalMutations(): boolean {\n    return this.documentState === DocumentState.HAS_LOCAL_MUTATIONS;\n  }\n\n  get hasCommittedMutations(): boolean {\n    return this.documentState === DocumentState.HAS_COMMITTED_MUTATIONS;\n  }\n\n  get hasPendingWrites(): boolean {\n    return this.hasLocalMutations || this.hasCommittedMutations;\n  }\n\n  isValidDocument(): boolean {\n    return this.documentType !== DocumentType.INVALID;\n  }\n\n  isFoundDocument(): boolean {\n    return this.documentType === DocumentType.FOUND_DOCUMENT;\n  }\n\n  isNoDocument(): boolean {\n    return this.documentType === DocumentType.NO_DOCUMENT;\n  }\n\n  isUnknownDocument(): boolean {\n    return this.documentType === DocumentType.UNKNOWN_DOCUMENT;\n  }\n\n  isEqual(other: Document | null | undefined): boolean {\n    return (\n      other instanceof MutableDocument &&\n      this.key.isEqual(other.key) &&\n      this.version.isEqual(other.version) &&\n      this.documentType === other.documentType &&\n      this.documentState === other.documentState &&\n      this.data.isEqual(other.data)\n    );\n  }\n\n  mutableCopy(): MutableDocument {\n    return new MutableDocument(\n      this.key,\n      this.documentType,\n      this.version,\n      this.readTime,\n      this.createTime,\n      this.data.clone(),\n      this.documentState\n    );\n  }\n\n  toString(): string {\n    return (\n      `Document(${this.key}, ${this.version}, ${JSON.stringify(\n        this.data.value\n      )}, ` +\n      `{createTime: ${this.createTime}}), ` +\n      `{documentType: ${this.documentType}}), ` +\n      `{documentState: ${this.documentState}})`\n    );\n  }\n}\n\n/**\n * Compares the value for field `field` in the provided documents. Throws if\n * the field does not exist in both documents.\n */\nexport function compareDocumentsByField(\n  field: FieldPath,\n  d1: Document,\n  d2: Document\n): number {\n  const v1 = d1.data.field(field);\n  const v2 = d2.data.field(field);\n  if (v1 !== null && v2 !== null) {\n    return valueCompare(v1, v2);\n  } else {\n    return fail(\n      0xa786,\n      \"Trying to compare documents on fields that don't exist\"\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { isReferenceValue, valueCompare, valueEquals } from '../model/values';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport { debugAssert } from '../util/assert';\n\nimport { Direction, OrderBy } from './order_by';\n\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nexport class Bound {\n  constructor(readonly position: ProtoValue[], readonly inclusive: boolean) {}\n}\n\nfunction boundCompareToDocument(\n  bound: Bound,\n  orderBy: OrderBy[],\n  doc: Document\n): number {\n  debugAssert(\n    bound.position.length <= orderBy.length,\n    \"Bound has more components than query's orderBy\"\n  );\n  let comparison = 0;\n  for (let i = 0; i < bound.position.length; i++) {\n    const orderByComponent = orderBy[i];\n    const component = bound.position[i];\n    if (orderByComponent.field.isKeyField()) {\n      debugAssert(\n        isReferenceValue(component),\n        'Bound has a non-key value where the key path is being used.'\n      );\n      comparison = DocumentKey.comparator(\n        DocumentKey.fromName(component.referenceValue),\n        doc.key\n      );\n    } else {\n      const docValue = doc.data.field(orderByComponent.field);\n      debugAssert(\n        docValue !== null,\n        'Field should exist since document matched the orderBy already.'\n      );\n      comparison = valueCompare(component, docValue);\n    }\n    if (orderByComponent.dir === Direction.DESCENDING) {\n      comparison = comparison * -1;\n    }\n    if (comparison !== 0) {\n      break;\n    }\n  }\n  return comparison;\n}\n\n/**\n * Returns true if a document sorts after a bound using the provided sort\n * order.\n */\nexport function boundSortsAfterDocument(\n  bound: Bound,\n  orderBy: OrderBy[],\n  doc: Document\n): boolean {\n  const comparison = boundCompareToDocument(bound, orderBy, doc);\n  return bound.inclusive ? comparison >= 0 : comparison > 0;\n}\n\n/**\n * Returns true if a document sorts before a bound using the provided sort\n * order.\n */\nexport function boundSortsBeforeDocument(\n  bound: Bound,\n  orderBy: OrderBy[],\n  doc: Document\n): boolean {\n  const comparison = boundCompareToDocument(bound, orderBy, doc);\n  return bound.inclusive ? comparison <= 0 : comparison < 0;\n}\n\nexport function boundEquals(left: Bound | null, right: Bound | null): boolean {\n  if (left === null) {\n    return right === null;\n  } else if (right === null) {\n    return false;\n  }\n\n  if (\n    left.inclusive !== right.inclusive ||\n    left.position.length !== right.position.length\n  ) {\n    return false;\n  }\n  for (let i = 0; i < left.position.length; i++) {\n    const leftPosition = left.position[i];\n    const rightPosition = right.position[i];\n    if (!valueEquals(leftPosition, rightPosition)) {\n      return false;\n    }\n  }\n  return true;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FieldPath } from '../model/path';\n\n/**\n * The direction of sorting in an order by.\n */\nexport const enum Direction {\n  ASCENDING = 'asc',\n  DESCENDING = 'desc'\n}\n\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nexport class OrderBy {\n  constructor(\n    readonly field: FieldPath,\n    readonly dir: Direction = Direction.ASCENDING\n  ) {}\n}\n\nexport function canonifyOrderBy(orderBy: OrderBy): string {\n  // TODO(b/29183165): Make this collision robust.\n  return orderBy.field.canonicalString() + orderBy.dir;\n}\n\nexport function stringifyOrderBy(orderBy: OrderBy): string {\n  return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\n}\n\nexport function orderByEquals(left: OrderBy, right: OrderBy): boolean {\n  return left.dir === right.dir && left.field.isEqual(right.field);\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { FieldPath } from '../model/path';\nimport {\n  arrayValueContains,\n  canonicalId,\n  isArray,\n  isReferenceValue,\n  typeOrder,\n  valueCompare,\n  valueEquals\n} from '../model/values';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport { debugAssert, fail } from '../util/assert';\n\n// The operator of a FieldFilter\nexport const enum Operator {\n  LESS_THAN = '<',\n  LESS_THAN_OR_EQUAL = '<=',\n  EQUAL = '==',\n  NOT_EQUAL = '!=',\n  GREATER_THAN = '>',\n  GREATER_THAN_OR_EQUAL = '>=',\n  ARRAY_CONTAINS = 'array-contains',\n  IN = 'in',\n  NOT_IN = 'not-in',\n  ARRAY_CONTAINS_ANY = 'array-contains-any'\n}\n\n// The operator of a CompositeFilter\nexport const enum CompositeOperator {\n  OR = 'or',\n  AND = 'and'\n}\n\nexport abstract class Filter {\n  abstract matches(doc: Document): boolean;\n\n  abstract getFlattenedFilters(): readonly FieldFilter[];\n\n  abstract getFilters(): Filter[];\n}\n\nexport class FieldFilter extends Filter {\n  protected constructor(\n    public readonly field: FieldPath,\n    public readonly op: Operator,\n    public readonly value: ProtoValue\n  ) {\n    super();\n  }\n\n  /**\n   * Creates a filter based on the provided arguments.\n   */\n  static create(\n    field: FieldPath,\n    op: Operator,\n    value: ProtoValue\n  ): FieldFilter {\n    if (field.isKeyField()) {\n      if (op === Operator.IN || op === Operator.NOT_IN) {\n        return this.createKeyFieldInFilter(field, op, value);\n      } else {\n        debugAssert(\n          isReferenceValue(value),\n          'Comparing on key, but filter value not a RefValue'\n        );\n        debugAssert(\n          op !== Operator.ARRAY_CONTAINS && op !== Operator.ARRAY_CONTAINS_ANY,\n          `'${op.toString()}' queries don't make sense on document keys.`\n        );\n        return new KeyFieldFilter(field, op, value);\n      }\n    } else if (op === Operator.ARRAY_CONTAINS) {\n      return new ArrayContainsFilter(field, value);\n    } else if (op === Operator.IN) {\n      debugAssert(\n        isArray(value),\n        'IN filter has invalid value: ' + value.toString()\n      );\n      return new InFilter(field, value);\n    } else if (op === Operator.NOT_IN) {\n      debugAssert(\n        isArray(value),\n        'NOT_IN filter has invalid value: ' + value.toString()\n      );\n      return new NotInFilter(field, value);\n    } else if (op === Operator.ARRAY_CONTAINS_ANY) {\n      debugAssert(\n        isArray(value),\n        'ARRAY_CONTAINS_ANY filter has invalid value: ' + value.toString()\n      );\n      return new ArrayContainsAnyFilter(field, value);\n    } else {\n      return new FieldFilter(field, op, value);\n    }\n  }\n\n  private static createKeyFieldInFilter(\n    field: FieldPath,\n    op: Operator.IN | Operator.NOT_IN,\n    value: ProtoValue\n  ): FieldFilter {\n    debugAssert(\n      isArray(value),\n      `Comparing on key with ${op.toString()}` +\n        ', but filter value not an ArrayValue'\n    );\n    debugAssert(\n      (value.arrayValue.values || []).every(elem => isReferenceValue(elem)),\n      `Comparing on key with ${op.toString()}` +\n        ', but an array value was not a RefValue'\n    );\n\n    return op === Operator.IN\n      ? new KeyFieldInFilter(field, value)\n      : new KeyFieldNotInFilter(field, value);\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.data.field(this.field);\n    // Types do not have to match in NOT_EQUAL filters.\n    if (this.op === Operator.NOT_EQUAL) {\n      return (\n        other !== null &&\n        other.nullValue === undefined &&\n        this.matchesComparison(valueCompare(other!, this.value))\n      );\n    }\n\n    // Only compare types with matching backend order (such as double and int).\n    return (\n      other !== null &&\n      typeOrder(this.value) === typeOrder(other) &&\n      this.matchesComparison(valueCompare(other, this.value))\n    );\n  }\n\n  protected matchesComparison(comparison: number): boolean {\n    switch (this.op) {\n      case Operator.LESS_THAN:\n        return comparison < 0;\n      case Operator.LESS_THAN_OR_EQUAL:\n        return comparison <= 0;\n      case Operator.EQUAL:\n        return comparison === 0;\n      case Operator.NOT_EQUAL:\n        return comparison !== 0;\n      case Operator.GREATER_THAN:\n        return comparison > 0;\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return comparison >= 0;\n      default:\n        return fail(0xb8a2, 'Unknown FieldFilter operator', {\n          operator: this.op\n        });\n    }\n  }\n\n  isInequality(): boolean {\n    return (\n      [\n        Operator.LESS_THAN,\n        Operator.LESS_THAN_OR_EQUAL,\n        Operator.GREATER_THAN,\n        Operator.GREATER_THAN_OR_EQUAL,\n        Operator.NOT_EQUAL,\n        Operator.NOT_IN\n      ].indexOf(this.op) >= 0\n    );\n  }\n\n  getFlattenedFilters(): readonly FieldFilter[] {\n    return [this];\n  }\n\n  getFilters(): Filter[] {\n    return [this];\n  }\n}\n\nexport class CompositeFilter extends Filter {\n  private memoizedFlattenedFilters: FieldFilter[] | null = null;\n\n  protected constructor(\n    public readonly filters: readonly Filter[],\n    public readonly op: CompositeOperator\n  ) {\n    super();\n  }\n\n  /**\n   * Creates a filter based on the provided arguments.\n   */\n  static create(filters: Filter[], op: CompositeOperator): CompositeFilter {\n    return new CompositeFilter(filters, op);\n  }\n\n  matches(doc: Document): boolean {\n    if (compositeFilterIsConjunction(this)) {\n      // For conjunctions, all filters must match, so return false if any filter doesn't match.\n      return this.filters.find(filter => !filter.matches(doc)) === undefined;\n    } else {\n      // For disjunctions, at least one filter should match.\n      return this.filters.find(filter => filter.matches(doc)) !== undefined;\n    }\n  }\n\n  getFlattenedFilters(): readonly FieldFilter[] {\n    if (this.memoizedFlattenedFilters !== null) {\n      return this.memoizedFlattenedFilters;\n    }\n\n    this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\n      return result.concat(subfilter.getFlattenedFilters());\n    }, [] as FieldFilter[]);\n\n    return this.memoizedFlattenedFilters;\n  }\n\n  // Returns a mutable copy of `this.filters`\n  getFilters(): Filter[] {\n    return Object.assign([], this.filters);\n  }\n}\n\nexport function compositeFilterIsConjunction(\n  compositeFilter: CompositeFilter\n): boolean {\n  return compositeFilter.op === CompositeOperator.AND;\n}\n\nexport function compositeFilterIsDisjunction(\n  compositeFilter: CompositeFilter\n): boolean {\n  return compositeFilter.op === CompositeOperator.OR;\n}\n\n/**\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\n */\nexport function compositeFilterIsFlatConjunction(\n  compositeFilter: CompositeFilter\n): boolean {\n  return (\n    compositeFilterIsFlat(compositeFilter) &&\n    compositeFilterIsConjunction(compositeFilter)\n  );\n}\n\n/**\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\n */\nexport function compositeFilterIsFlat(\n  compositeFilter: CompositeFilter\n): boolean {\n  for (const filter of compositeFilter.filters) {\n    if (filter instanceof CompositeFilter) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function canonifyFilter(filter: Filter): string {\n  debugAssert(\n    filter instanceof FieldFilter || filter instanceof CompositeFilter,\n    'canonifyFilter() only supports FieldFilters and CompositeFilters'\n  );\n\n  if (filter instanceof FieldFilter) {\n    // TODO(b/29183165): Technically, this won't be unique if two values have\n    // the same description, such as the int 3 and the string \"3\". So we should\n    // add the types in here somehow, too.\n    return (\n      filter.field.canonicalString() +\n      filter.op.toString() +\n      canonicalId(filter.value)\n    );\n  } else if (compositeFilterIsFlatConjunction(filter)) {\n    // Older SDK versions use an implicit AND operation between their filters.\n    // In the new SDK versions, the developer may use an explicit AND filter.\n    // To stay consistent with the old usages, we add a special case to ensure\n    // the canonical ID for these two are the same. For example:\n    // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\n    // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\n    return filter.filters.map(filter => canonifyFilter(filter)).join(',');\n  } else {\n    // filter instanceof CompositeFilter\n    const canonicalIdsString = filter.filters\n      .map(filter => canonifyFilter(filter))\n      .join(',');\n    return `${filter.op}(${canonicalIdsString})`;\n  }\n}\n\nexport function filterEquals(f1: Filter, f2: Filter): boolean {\n  if (f1 instanceof FieldFilter) {\n    return fieldFilterEquals(f1, f2);\n  } else if (f1 instanceof CompositeFilter) {\n    return compositeFilterEquals(f1, f2);\n  } else {\n    fail(0x4bef, 'Only FieldFilters and CompositeFilters can be compared');\n  }\n}\n\nexport function fieldFilterEquals(f1: FieldFilter, f2: Filter): boolean {\n  return (\n    f2 instanceof FieldFilter &&\n    f1.op === f2.op &&\n    f1.field.isEqual(f2.field) &&\n    valueEquals(f1.value, f2.value)\n  );\n}\n\nexport function compositeFilterEquals(\n  f1: CompositeFilter,\n  f2: Filter\n): boolean {\n  if (\n    f2 instanceof CompositeFilter &&\n    f1.op === f2.op &&\n    f1.filters.length === f2.filters.length\n  ) {\n    const subFiltersMatch: boolean = f1.filters.reduce(\n      (result: boolean, f1Filter: Filter, index: number): boolean =>\n        result && filterEquals(f1Filter, f2.filters[index]),\n      true\n    );\n\n    return subFiltersMatch;\n  }\n\n  return false;\n}\n\n/**\n * Returns a new composite filter that contains all filter from\n * `compositeFilter` plus all the given filters in `otherFilters`.\n */\nexport function compositeFilterWithAddedFilters(\n  compositeFilter: CompositeFilter,\n  otherFilters: Filter[]\n): CompositeFilter {\n  const mergedFilters = compositeFilter.filters.concat(otherFilters);\n  return CompositeFilter.create(mergedFilters, compositeFilter.op);\n}\n\n/** Returns a debug description for `filter`. */\nexport function stringifyFilter(filter: Filter): string {\n  debugAssert(\n    filter instanceof FieldFilter || filter instanceof CompositeFilter,\n    'stringifyFilter() only supports FieldFilters and CompositeFilters'\n  );\n  if (filter instanceof FieldFilter) {\n    return stringifyFieldFilter(filter);\n  } else if (filter instanceof CompositeFilter) {\n    return stringifyCompositeFilter(filter);\n  } else {\n    return 'Filter';\n  }\n}\n\nexport function stringifyCompositeFilter(filter: CompositeFilter): string {\n  return (\n    filter.op.toString() +\n    ` {` +\n    filter.getFilters().map(stringifyFilter).join(' ,') +\n    '}'\n  );\n}\n\nexport function stringifyFieldFilter(filter: FieldFilter): string {\n  return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(\n    filter.value\n  )}`;\n}\n\n/** Filter that matches on key fields (i.e. '__name__'). */\nexport class KeyFieldFilter extends FieldFilter {\n  private readonly key: DocumentKey;\n\n  constructor(field: FieldPath, op: Operator, value: ProtoValue) {\n    super(field, op, value);\n    debugAssert(\n      isReferenceValue(value),\n      'KeyFieldFilter expects a ReferenceValue'\n    );\n    this.key = DocumentKey.fromName(value.referenceValue);\n  }\n\n  matches(doc: Document): boolean {\n    const comparison = DocumentKey.comparator(doc.key, this.key);\n    return this.matchesComparison(comparison);\n  }\n}\n\n/** Filter that matches on key fields within an array. */\nexport class KeyFieldInFilter extends FieldFilter {\n  private readonly keys: DocumentKey[];\n\n  constructor(field: FieldPath, value: ProtoValue) {\n    super(field, Operator.IN, value);\n    this.keys = extractDocumentKeysFromArrayValue(Operator.IN, value);\n  }\n\n  matches(doc: Document): boolean {\n    return this.keys.some(key => key.isEqual(doc.key));\n  }\n}\n\n/** Filter that matches on key fields not present within an array. */\nexport class KeyFieldNotInFilter extends FieldFilter {\n  private readonly keys: DocumentKey[];\n\n  constructor(field: FieldPath, value: ProtoValue) {\n    super(field, Operator.NOT_IN, value);\n    this.keys = extractDocumentKeysFromArrayValue(Operator.NOT_IN, value);\n  }\n\n  matches(doc: Document): boolean {\n    return !this.keys.some(key => key.isEqual(doc.key));\n  }\n}\n\nfunction extractDocumentKeysFromArrayValue(\n  op: Operator.IN | Operator.NOT_IN,\n  value: ProtoValue\n): DocumentKey[] {\n  debugAssert(\n    isArray(value),\n    'KeyFieldInFilter/KeyFieldNotInFilter expects an ArrayValue'\n  );\n  return (value.arrayValue?.values || []).map(v => {\n    debugAssert(\n      isReferenceValue(v),\n      `Comparing on key with ${op.toString()}, but an array value was not ` +\n        `a ReferenceValue`\n    );\n    return DocumentKey.fromName(v.referenceValue);\n  });\n}\n\n/** A Filter that implements the array-contains operator. */\nexport class ArrayContainsFilter extends FieldFilter {\n  constructor(field: FieldPath, value: ProtoValue) {\n    super(field, Operator.ARRAY_CONTAINS, value);\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.data.field(this.field);\n    return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n  }\n}\n\n/** A Filter that implements the IN operator. */\nexport class InFilter extends FieldFilter {\n  constructor(field: FieldPath, value: ProtoValue) {\n    super(field, Operator.IN, value);\n    debugAssert(isArray(value), 'InFilter expects an ArrayValue');\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.data.field(this.field);\n    return other !== null && arrayValueContains(this.value.arrayValue!, other);\n  }\n}\n\n/** A Filter that implements the not-in operator. */\nexport class NotInFilter extends FieldFilter {\n  constructor(field: FieldPath, value: ProtoValue) {\n    super(field, Operator.NOT_IN, value);\n    debugAssert(isArray(value), 'NotInFilter expects an ArrayValue');\n  }\n\n  matches(doc: Document): boolean {\n    if (\n      arrayValueContains(this.value.arrayValue!, { nullValue: 'NULL_VALUE' })\n    ) {\n      return false;\n    }\n    const other = doc.data.field(this.field);\n    return (\n      other !== null &&\n      other.nullValue === undefined &&\n      !arrayValueContains(this.value.arrayValue!, other)\n    );\n  }\n}\n\n/** A Filter that implements the array-contains-any operator. */\nexport class ArrayContainsAnyFilter extends FieldFilter {\n  constructor(field: FieldPath, value: ProtoValue) {\n    super(field, Operator.ARRAY_CONTAINS_ANY, value);\n    debugAssert(isArray(value), 'ArrayContainsAnyFilter expects an ArrayValue');\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.data.field(this.field);\n    if (!isArray(other) || !other.arrayValue.values) {\n      return false;\n    }\n    return other.arrayValue.values.some(val =>\n      arrayValueContains(this.value.arrayValue!, val)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentKey } from '../model/document_key';\nimport {\n  FieldIndex,\n  fieldIndexGetArraySegment,\n  fieldIndexGetDirectionalSegments,\n  IndexKind\n} from '../model/field_index';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport {\n  canonicalId,\n  MAX_VALUE,\n  MIN_VALUE,\n  lowerBoundCompare,\n  upperBoundCompare,\n  valuesGetLowerBound,\n  valuesGetUpperBound\n} from '../model/values';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport { debugCast } from '../util/assert';\nimport { SortedSet } from '../util/sorted_set';\nimport { isNullOrUndefined } from '../util/types';\n\nimport { Bound, boundEquals } from './bound';\nimport {\n  Filter,\n  FieldFilter,\n  canonifyFilter,\n  stringifyFilter,\n  filterEquals,\n  Operator\n} from './filter';\nimport {\n  canonifyOrderBy,\n  OrderBy,\n  orderByEquals,\n  stringifyOrderBy\n} from './order_by';\n\n/**\n * A Target represents the WatchTarget representation of a Query, which is used\n * by the LocalStore and the RemoteStore to keep track of and to execute\n * backend queries. While a Query can represent multiple Targets, each Targets\n * maps to a single WatchTarget in RemoteStore and a single TargetData entry\n * in persistence.\n */\nexport interface Target {\n  readonly path: ResourcePath;\n  readonly collectionGroup: string | null;\n  readonly orderBy: OrderBy[];\n  readonly filters: Filter[];\n  readonly limit: number | null;\n  readonly startAt: Bound | null;\n  readonly endAt: Bound | null;\n}\n\n// Visible for testing\nexport class TargetImpl implements Target {\n  memoizedCanonicalId: string | null = null;\n  constructor(\n    readonly path: ResourcePath,\n    readonly collectionGroup: string | null = null,\n    readonly orderBy: OrderBy[] = [],\n    readonly filters: Filter[] = [],\n    readonly limit: number | null = null,\n    readonly startAt: Bound | null = null,\n    readonly endAt: Bound | null = null\n  ) {}\n}\n\n/**\n * Initializes a Target with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n *\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n * using this factory method, because `Query` provides an implicit `orderBy`\n * property.\n */\nexport function newTarget(\n  path: ResourcePath,\n  collectionGroup: string | null = null,\n  orderBy: OrderBy[] = [],\n  filters: Filter[] = [],\n  limit: number | null = null,\n  startAt: Bound | null = null,\n  endAt: Bound | null = null\n): Target {\n  return new TargetImpl(\n    path,\n    collectionGroup,\n    orderBy,\n    filters,\n    limit,\n    startAt,\n    endAt\n  );\n}\n\nexport function canonifyTarget(target: Target): string {\n  const targetImpl = debugCast(target, TargetImpl);\n\n  if (targetImpl.memoizedCanonicalId === null) {\n    let str = targetImpl.path.canonicalString();\n    if (targetImpl.collectionGroup !== null) {\n      str += '|cg:' + targetImpl.collectionGroup;\n    }\n    str += '|f:';\n    str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\n    str += '|ob:';\n    str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\n\n    if (!isNullOrUndefined(targetImpl.limit)) {\n      str += '|l:';\n      str += targetImpl.limit!;\n    }\n    if (targetImpl.startAt) {\n      str += '|lb:';\n      str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\n      str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\n    }\n    if (targetImpl.endAt) {\n      str += '|ub:';\n      str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\n      str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\n    }\n    targetImpl.memoizedCanonicalId = str;\n  }\n  return targetImpl.memoizedCanonicalId;\n}\n\nexport function stringifyTarget(target: Target): string {\n  let str = target.path.canonicalString();\n  if (target.collectionGroup !== null) {\n    str += ' collectionGroup=' + target.collectionGroup;\n  }\n  if (target.filters.length > 0) {\n    str += `, filters: [${target.filters\n      .map(f => stringifyFilter(f))\n      .join(', ')}]`;\n  }\n  if (!isNullOrUndefined(target.limit)) {\n    str += ', limit: ' + target.limit;\n  }\n  if (target.orderBy.length > 0) {\n    str += `, orderBy: [${target.orderBy\n      .map(o => stringifyOrderBy(o))\n      .join(', ')}]`;\n  }\n  if (target.startAt) {\n    str += ', startAt: ';\n    str += target.startAt.inclusive ? 'b:' : 'a:';\n    str += target.startAt.position.map(p => canonicalId(p)).join(',');\n  }\n  if (target.endAt) {\n    str += ', endAt: ';\n    str += target.endAt.inclusive ? 'a:' : 'b:';\n    str += target.endAt.position.map(p => canonicalId(p)).join(',');\n  }\n  return `Target(${str})`;\n}\n\nexport function targetEquals(left: Target, right: Target): boolean {\n  if (left.limit !== right.limit) {\n    return false;\n  }\n\n  if (left.orderBy.length !== right.orderBy.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.orderBy.length; i++) {\n    if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\n      return false;\n    }\n  }\n\n  if (left.filters.length !== right.filters.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.filters.length; i++) {\n    if (!filterEquals(left.filters[i], right.filters[i])) {\n      return false;\n    }\n  }\n\n  if (left.collectionGroup !== right.collectionGroup) {\n    return false;\n  }\n\n  if (!left.path.isEqual(right.path)) {\n    return false;\n  }\n\n  if (!boundEquals(left.startAt, right.startAt)) {\n    return false;\n  }\n\n  return boundEquals(left.endAt, right.endAt);\n}\n\nexport function targetIsDocumentTarget(target: Target): boolean {\n  return (\n    DocumentKey.isDocumentKey(target.path) &&\n    target.collectionGroup === null &&\n    target.filters.length === 0\n  );\n}\n\n/** Returns the field filters that target the given field path. */\nexport function targetGetFieldFiltersForPath(\n  target: Target,\n  path: FieldPath\n): FieldFilter[] {\n  return target.filters.filter(\n    f => f instanceof FieldFilter && f.field.isEqual(path)\n  ) as FieldFilter[];\n}\n\n/**\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\n * filters. Returns `null` if there are no such filters.\n */\nexport function targetGetArrayValues(\n  target: Target,\n  fieldIndex: FieldIndex\n): ProtoValue[] | null {\n  const segment = fieldIndexGetArraySegment(fieldIndex);\n  if (segment === undefined) {\n    return null;\n  }\n\n  for (const fieldFilter of targetGetFieldFiltersForPath(\n    target,\n    segment.fieldPath\n  )) {\n    switch (fieldFilter.op) {\n      case Operator.ARRAY_CONTAINS_ANY:\n        return fieldFilter.value.arrayValue!.values || [];\n      case Operator.ARRAY_CONTAINS:\n        return [fieldFilter.value];\n      default:\n      // Remaining filters are not array filters.\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the list of values that are used in != or NOT_IN filters. Returns\n * `null` if there are no such filters.\n */\nexport function targetGetNotInValues(\n  target: Target,\n  fieldIndex: FieldIndex\n): ProtoValue[] | null {\n  const values = new Map</* fieldPath = */ string, ProtoValue>();\n\n  for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n    for (const fieldFilter of targetGetFieldFiltersForPath(\n      target,\n      segment.fieldPath\n    )) {\n      switch (fieldFilter.op) {\n        case Operator.EQUAL:\n        case Operator.IN:\n          // Encode equality prefix, which is encoded in the index value before\n          // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\n          // `value != 'ab'`).\n          values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n          break;\n        case Operator.NOT_IN:\n        case Operator.NOT_EQUAL:\n          // NotIn/NotEqual is always a suffix. There cannot be any remaining\n          // segments and hence we can return early here.\n          values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n          return Array.from(values.values());\n        default:\n        // Remaining filters cannot be used as notIn bounds.\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Returns a lower bound of field values that can be used as a starting point to\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\n * exists.\n */\nexport function targetGetLowerBound(\n  target: Target,\n  fieldIndex: FieldIndex\n): Bound {\n  const values: ProtoValue[] = [];\n  let inclusive = true;\n\n  // For each segment, retrieve a lower bound if there is a suitable filter or\n  // startAt.\n  for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n    const segmentBound =\n      segment.kind === IndexKind.ASCENDING\n        ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\n        : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\n\n    values.push(segmentBound.value);\n    inclusive &&= segmentBound.inclusive;\n  }\n  return new Bound(values, inclusive);\n}\n\n/**\n * Returns an upper bound of field values that can be used as an ending point\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\n * upper bound exists.\n */\nexport function targetGetUpperBound(\n  target: Target,\n  fieldIndex: FieldIndex\n): Bound {\n  const values: ProtoValue[] = [];\n  let inclusive = true;\n\n  // For each segment, retrieve an upper bound if there is a suitable filter or\n  // endAt.\n  for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n    const segmentBound =\n      segment.kind === IndexKind.ASCENDING\n        ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\n        : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\n\n    values.push(segmentBound.value);\n    inclusive &&= segmentBound.inclusive;\n  }\n\n  return new Bound(values, inclusive);\n}\n\n/**\n * Returns the value to use as the lower bound for ascending index segment at\n * the provided `fieldPath` (or the upper bound for an descending segment).\n */\nfunction targetGetAscendingBound(\n  target: Target,\n  fieldPath: FieldPath,\n  bound: Bound | null\n): { value: ProtoValue; inclusive: boolean } {\n  let value: ProtoValue = MIN_VALUE;\n\n  let inclusive = true;\n\n  // Process all filters to find a value for the current field segment\n  for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n    let filterValue: ProtoValue = MIN_VALUE;\n    let filterInclusive = true;\n\n    switch (fieldFilter.op) {\n      case Operator.LESS_THAN:\n      case Operator.LESS_THAN_OR_EQUAL:\n        filterValue = valuesGetLowerBound(fieldFilter.value);\n        break;\n      case Operator.EQUAL:\n      case Operator.IN:\n      case Operator.GREATER_THAN_OR_EQUAL:\n        filterValue = fieldFilter.value;\n        break;\n      case Operator.GREATER_THAN:\n        filterValue = fieldFilter.value;\n        filterInclusive = false;\n        break;\n      case Operator.NOT_EQUAL:\n      case Operator.NOT_IN:\n        filterValue = MIN_VALUE;\n        break;\n      default:\n      // Remaining filters cannot be used as lower bounds.\n    }\n\n    if (\n      lowerBoundCompare(\n        { value, inclusive },\n        { value: filterValue, inclusive: filterInclusive }\n      ) < 0\n    ) {\n      value = filterValue;\n      inclusive = filterInclusive;\n    }\n  }\n\n  // If there is an additional bound, compare the values against the existing\n  // range to see if we can narrow the scope.\n  if (bound !== null) {\n    for (let i = 0; i < target.orderBy.length; ++i) {\n      const orderBy = target.orderBy[i];\n      if (orderBy.field.isEqual(fieldPath)) {\n        const cursorValue = bound.position[i];\n        if (\n          lowerBoundCompare(\n            { value, inclusive },\n            { value: cursorValue, inclusive: bound.inclusive }\n          ) < 0\n        ) {\n          value = cursorValue;\n          inclusive = bound.inclusive;\n        }\n        break;\n      }\n    }\n  }\n\n  return { value, inclusive };\n}\n\n/**\n * Returns the value to use as the upper bound for ascending index segment at\n * the provided `fieldPath` (or the lower bound for a